/* -*- crc -*- 
 *
 * 
 *
 * Purpose:
 *   This module contains common industrial rules used in Carmen Crew Rostering
 *   and as studio only in Carmen Crew Tracking.
 *
 * Sections:
 *   1. Duty rules (7x24, 4weeks, month)
 *   2. Block time rules
 *   3. Rest rules
 *   4. Freeday rules
 *   5. Restrictions
 *
 * Created by:
 *   Henrik Albertson, 24-Jan-2005
 *
 * Major changes:
 *
 */

root module rules_indust_ccr

import calendar;
import levels;
import fundamental;
import iterators;
import system_db_parameters;
import parameters;
import base_product;
import crew;
import leg;
import duty;
import trip;
import wop;
import oma16;
import month;
import roster;
import model_freedays;
import freedays;
import theme_prod;
import rest;
import duty_time;
import accumulators;
import pp;
import rule_exceptions;
import rules;
import bought_days;
import task;
import training;
import standby;
import attributes;
import duty_period;
import base_utils;
import base_calendar;
import model_crew;
import fdp;
import bunkering;



/* create seperation and header from to other parameters preceeding this list in "ALL PARAMETERS" */
%tab_header% =
  parameter "..."
  remark "#HEADER#Rules Indust CCR";

/****************************************************************
 * Section 1: Duty rules
 ***************************************************************/

export %time_of_day_wop_end_hb_not_zero% =
  if time_of_day(wop.%end_hb%) = 0:00 then
     24:00
  else
    time_of_day(wop.%end_hb%);

/*
** Rule:
**   Maximum duty time in 7 calendar days start day  
**
** Description:
**    Check duty time in 7 calendar days backwards from the day on which a
**    duty starts, using Subpart Q duty time calculation.     
**
** Agreement:
**   4ExNG CC 6.3.1.1.A.
**   4ExNG FC 6.1.5
**   K22 FD 5.3 - SKCMS-3065
**
** NOTE:
**  Resource constraint for CG for this rule is defined in cg_model
**
*/
%duty_time_in_7_days_start_day_ALL_logic% = 
  if duty_time.%7_days_start_day% >=  %max_duty_time_in_7_days_fd_soft_limit% and 
  duty_time.%7_days_start_day% < %max_duty_time_in_7_days%  then  
                %max_duty_time_in_7_days_fd_soft_limit% 
  else  %max_duty_time_in_7_days% ;

export rule ind_max_duty_time_in_7_days_start_day_ALL =
  valid trip.%check_rules% and
        not crew.%is_asian% and
        duty.%in_pp_extended% and
        duty_period.%is_on_duty% and
        duty_period.%is_last_duty_period_on_start_day% and
        duty_period.%is_first_duty_in_duty_period% ;

    duty_time.%7_days_start_day% <= %max_duty_time_in_7_days% +
                rule_exceptions.%overshoot_rel_on_off%(duty.%start_UTC%);

  startdate = duty.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = %ind_max_duty_in_7_days_start_day_ALL_failobject%;
  failtext(Reltime value, Reltime limit) =
    %ind_max_duty_in_7_days_start_day_ALL_failtext%(value, limit);
  remark "(CCR) Coll: Max duty time in 7 days from duty start day",
  planner "The rule checks that the total duty time in 7 calendar days"
          " backwards from the day on which the duty starts is less than"
          " maximum allowed.";
end

%ind_max_duty_in_7_days_start_day_ALL_failobject% =
  let start_7_days = duty_period.%last_7_days_start_day_start%,
      end_7_days = duty_period.%last_7_days_start_day_end%,
      overshoot = default(rule_exceptions.%overshoot_rel%(duty.%start_UTC%), 0:00);
  last(leg(duty),
       prev(leg(chain),next(leg(chain),leg.%failobject_departure%)) where
        (oma16.%duty_time_in_interval_indust%( start_7_days, leg.%co_end_utc%) <=
         %max_duty_time_in_7_days% + overshoot))
    where (leg.%start_UTC% <= end_7_days);
  
%ind_max_duty_in_7_days_start_day_ALL_failtext%(Reltime value, Reltime limit) =
  let normal = duty_time.%7_days_start_day% >= %max_duty_time_in_7_days%,
      soft_limit = duty_time.%7_days_start_day% >= %max_duty_time_in_7_days_fd_soft_limit% and duty_time.%7_days_start_day% < %max_duty_time_in_7_days% ,
      normal_warning = if normal then "Coll: Duty time in 7 days " else "Soft: Duty time in 7 days generates overtime ",
      new_limit = if normal 
                  then %max_duty_time_in_7_days%
                  else if soft_limit then %max_duty_time_in_7_days_fd_soft_limit% 
                  else %max_duty_time_in_7_days%;
  rules.%failtext_rel%(concat(normal_warning ,
                              format_time( duty_period.%last_7_days_start_day_start% +
                                          duty.%homebase_tz_corrector%,"%d%b"),
                              "-",
                              format_time( duty_period.%last_7_days_start_day_end% +
                                          duty.%homebase_tz_corrector% - 24:00,
                                          "%d%b")),
                        duty_time.%7_days_start_day%, new_limit);

export %max_duty_time_in_7_days% =   
  theme_prod.%max_duty_time_in_7_days%;

/*
** Rule:
**   Maximum duty time in 7 calendar days end day  
**
** Description:
**    Check duty time in 7 calendar days backwards from the day on which a
**    duty ends.     
**
** Agreement:
**   4ExNG CC 6.3.1.1.A.
**   4ExNG FC 6.1.5
**   K22 FD 5.3 - SKCMS-3065
*/

%duty_time_in_7_days_end_day_ALL_logic% = 
  if duty_time.%7_days_end_day% >=  %max_duty_time_in_7_days_fd_soft_limit% and 
  duty_time.%7_days_end_day% < %max_duty_time_in_7_days%  then  
                %max_duty_time_in_7_days_fd_soft_limit% 
  else  %max_duty_time_in_7_days% ;

rule ind_max_duty_time_in_7_days_end_day_ALL =
  valid trip.%check_rules%  and
        not crew.%is_asian% and
        duty.%in_pp_extended% and
        duty_period.%is_on_duty% and
        duty_period.%is_last_duty_period_on_start_day% and
        duty_period.%is_last_duty_in_duty_period% and
        duty_time.%ends_on_day_after_start_hb%;

  duty_time.%7_days_end_day% <= %duty_time_in_7_days_end_day_ALL_logic% + rule_exceptions.%overshoot_rel_on_off%(duty.%start_UTC%) ;

  startdate = duty.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = %ind_max_duty_in_7_days_end_day_ALL_failboject%;
  failtext(Reltime value, Reltime limit) =
    %ind_max_duty_in_7_days_end_day_ALL_failtext%(value, limit);
  remark "(CCR) Coll: Max duty time in 7 days from duty end day",
  planner "The rule checks that the total duty time in 7 calendar days"
          " backwards from the day on which the duty ends, when it ends on the"
          " day after it started and there is no duty starting on that day, is"
          " less than maximum allowed.";
end

%ind_max_duty_in_7_days_end_day_ALL_failboject% =
  let start_7_days = duty_period.%last_7_days_start_day_start%,
      end_7_days = duty_period.%last_7_days_start_day_end%,
      overshoot = default(rule_exceptions.%overshoot_rel%(duty.%start_UTC%), 0:00);
  last(leg(duty),
       prev(leg(chain),next(leg(chain),leg.%failobject_departure%)) where
        (oma16.%duty_time_in_interval_indust%( start_7_days, leg.%co_end_utc%) <=
         %max_duty_time_in_7_days% + overshoot))
    where (leg.%start_utc% < end_7_days);

%ind_max_duty_in_7_days_end_day_ALL_failtext%(Reltime value, Reltime limit) =
  let normal = duty_time.%7_days_end_day% >= %max_duty_time_in_7_days%,
      soft_limit = duty_time.%7_days_end_day% >= %max_duty_time_in_7_days_fd_soft_limit% and duty_time.%7_days_end_day% < %max_duty_time_in_7_days% ,
      normal_warning = if normal then "Coll: Duty time in 7 days " else "Soft: Duty time in 7 days generates overtime ",
      new_limit = if normal 
                  then %max_duty_time_in_7_days%
                  else if soft_limit then %max_duty_time_in_7_days_fd_soft_limit% 
                  else %max_duty_time_in_7_days%;
  rules.%failtext_rel%(concat(normal_warning ,
                              format_time( duty_period.%last_7_days_start_day_start% +
                                          duty.%homebase_tz_corrector% + 24:00,
                                          "%d%b"),
                              "-",
                              format_time( duty_period.%last_7_days_start_day_end% + 
                                          duty.%homebase_tz_corrector%,"%d%b")),
                       duty_time.%7_days_end_day%, new_limit);
%max_duty_time_in_7_days_fd_soft_limit% =
  parameter 47:30
  remark "Soft limit for max duty time in 7 days FD";      

/*
** Rule: 
**    Maximum duty time in 4 weeks
**
** Description:
**    The rule checks that the duty time with or without night upgrade in
**    4 weeks forwards is less than the maximum allowed. For FC the duty time
**    is including night upgrade whereas for JAP the duty time is excluding
**    night upgrade.
** 
** Agreement:
**    FC 1:3 mom3.a
**    JCC 3.1 (Japanese crew)
**
** Valid for:
**    FC, JAP CC
** 
** CR:
**    
*/
export rule ind_max_duty_time_in_4_weeks_FC_JAP =
  valid roster.%check_rules% and
        %r_valid_duty_time_4_weeks% and
        trip.%in_pp_extended% and
        trip.%is_on_duty% and
        trip.%is_last_in_week%;

  %duty_time_4_weeks% <= duty_time.%max_in_4_weeks% + 
  			 rule_exceptions.%overshoot_rel%(trip.%start_UTC%);

  startdate = trip.%start_UTC%;
  severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = %ind_max_duty_time_in_4_weeks_FC_JAP_failobject%;
  failtext(Reltime value, Reltime limit) =
    rules.%failtext_rel%("Coll: Duty time (4 week)", value, limit);
  remark "(CCR) Coll: Max duty time in 4 weeks",
  planner "The rule checks that maximum duty time in 4 weeks (checked"
          " backwards) is not exceeded. The rule is valid for FC under"
          " education and CC JAP.";
end

%ind_max_duty_time_in_4_weeks_FC_JAP_failobject% =
  first(leg(trip), leg.%failobject_departure%)
  where(%duty_time_4_weeks_until_now% > duty_time.%max_in_4_weeks% + 
  			 rule_exceptions.%overshoot_rel%(trip.%start_UTC%));

/* Defined in child modules, because of different duty limits and validity for CC and FC. */
%r_valid_duty_time_4_weeks% = Bool;
%duty_time_4_weeks% = Reltime;
%duty_time_4_weeks_until_now% = Reltime;

/* Defined in child modules, because of different validity for CC and FC. */
%r_valid_duty_time_calendar_month% = Bool;
%duty_time_calendar_month% = Reltime; /* No night upgrade for CC */
%duty_time_calendar_month_until_now% = Reltime;



/*
** Rule: 
**    No duty same day when check out later than 0200
**
** Descritption:
**    Check that crew does not check in for duty if the check out from previous
**    duty is later than 0200 local time and at homebase.
**
** Agreement:
**    FC 1:17 2.3Ad
**    SCCA praxis
**
** Valid for:
**    All
** 
**    4ExNG CC - no longer applies
**    
*/
export rule ind_no_duty_same_day_when_late_check_out_FC_SKD_SKS =
  valid roster.%check_rules% and
        not crew.%k4exng_cc_sp5_1_valid%(trip.%start_day%) and
        not crew.%is_leased_trip_start% and
        %r_valid_no_duty_same_day_if_late_co% and
        crew.%is_short_haul_trip_start% and /* Is this correct for all regions??? */
        trip.%in_pp_extended% and
        trip.%is_on_duty% and
        not trip.%is_rest% and
        not is_first(trip(wop)) and
        %trip_start_same_day_as_prev_trip_end_with_late_check_out% and
        not prev(trip(wop), trip.%is_standby%) and
        not trip.%is_standby% and
        not first(duty(trip),duty.%is_bought%) and
        not prev(trip(wop),last(duty(trip),duty.%is_bought%)) and
        rule_exceptions.%rule_on%(trip.%start_UTC%);

  %prev_trip_end_od% <= %latest_co_for_duty_next_day%;
  
  startdate = trip.%start_UTC%;
  severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = trip.%failobject_start%;
  failtext "Coll: C/I same day as late C/O";
  remark "(CCR) Coll: No check in for duty same day when late check out",
  planner "The rule checks that if there is a new trip assigned the same day as"
          " the previous trip ends, check out for that trip is not later than"
          " 02:00. The rule is valid for FCSH and SH crew in SKD & SKS.";
end

%latest_co_for_duty_next_day% = 02:00;

/* Defined in child modules due to different values for CC and FC. */
%r_valid_no_duty_same_day_if_late_co% = Bool;
%trip_start_same_day_as_prev_trip_end_with_late_check_out% = Bool;
%prev_trip_end_od% = Reltime;


/*
** Rule: 
**    Maximum number of working days between freedays
**
** Description:
**    Check that the maximum number of working days between freedays 
**    (i.e. in a wop) is not exceeded. The limits can be found implicitly
**    in the paragraphs below.
**
**    If a wop consists entirely of standby line days, it is not checked
**    If a wop consists of standby line days with the last having a call-out,
**    the unused standby line days are not counted as working days
**
**    NB! Three implementations are done. One in CCP checking trip length
**    and this one in CCR checking working period length and one in CCT that
**    regards "holes" as production.
**
**    Cimber CC and FD are excluded from this rule: SKCMS-609
** Agreement:
**    FC 1:18 2.5b
**    CAU J.1.1, J.2.1.3
**    NKF ???
**    SCCA H.1 H.2.3
**
**    4ExNG - rule applies to SKD temps
**
** NOTE:
**  Resource constraint for CG for this rule is defined in cg_model
*/
export rule ind_max_working_days_btw_freedays_ALL =
  valid %ind_max_working_days_btw_freedays_ALL_valid%;

  freedays.%work_days_btw_freedays% <= %max_days_btw_freedays% + 
		rule_exceptions.%overshoot_int%(wop.%start_UTC%);

  startdate  = wop.%start_UTC%;
  severity = first(leg(wop), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = %ind_max_working_days_btw_freedays_ALL_failobject%
                 (rule_exceptions.%overshoot_int%(wop.%start_UTC%));
  failtext(Int value, Int limit) =
    rules.%failtext_int%("(CCR) Coll: Workdays btw F-days", value, limit);
  remark "(CCR) Coll: Max working days between freedays",
  planner "The rule checks that the maximum allowed working days are"
          " not exceeded. The limits are 5 days (SH) and 12 days (LH)"
          " and for FPU limit is 7 days. After single f 4 or possibly less.";
end

export %ind_max_working_days_btw_freedays_ALL_valid% =
    %is_roster% and
    not crew.%is_leased_wop_start% and
    not (crew.%is_skj% or crew.%is_skk%) and
    wop.%completely_in_pp% and
    wop.%is_on_duty% and
    not wop.%is_standby_line%;

%ind_max_working_days_btw_freedays_ALL_failobject%(Int overshoot) =
  let limit = %max_days_btw_freedays% +
              default(overshoot,0); 
  default(first(duty(wop) where (wop.%days_in_period%(wop.%start_hb%, duty.%end_hb%) >
                                 limit), 
                 duty.%failobject_start%),
           wop.%failobject_start%);

export %max_days_btw_freedays% =
    theme_prod.%max_days_btw_freedays%;

/*
** Rule:
**    Long haul trip must be followed by freedays
**
** Description:
**    Check that a long haul trip is followed by freedays,
**    i.e. check that the wop is terminated when arriving
**    to homebase after a long haul trip. In rostering this
**    is also valid for standby-lines.
**
**    NB! Two implementations of this rule is done, One in CCP,
**    checking last in trip and one in CCR checking last in wop.
**
** Agreement:
**    FC G.1.11d
**    CAU H.2.1.5
**    NKF ???
**    SCCA D.1.2
*/
export rule ind_long_haul_trip_last_in_wop_ALL =
  valid roster.%check_rules% and
        not crew.%is_leased_trip_start% and
        not (crew.%is_skd% and crew.%is_temporary%) and
        wop.%in_pp% and
        wop.%is_on_duty% and
        (trip.%is_long_haul% or %trip_is_sby_line_to_be_checked%) and
        not(last(duty(trip),duty.%is_bought%)) and
        not(last(duty(trip),next(duty(wop),duty.%is_bought%))) and
        rule_exceptions.%rule_on%(trip.%start_UTC%);
        
  is_last(trip(wop)) where(not trip.%is_off_duty_cmp%);
  
  startdate  = trip.%start_UTC%;
  severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = next(trip(wop), trip.%failobject_start%);
  failtext "Coll: LH trip not followed by F-days";
  remark "(CCR) Coll: Long haul trip must be followed by freedays",
  planner "Check that a long haul trip is followed by freedays,"
          " i.e. the trip is last in the working period.";
end

%duty_followed_by_2_freedays_or_bought_days% =
  is_last(duty(wop)) or
  (next(duty(chain),duty.%start_day%) where 
       (not duty.%is_bought% and duty.%is_on_duty% and 
        not duty.%is_compensation_day%) -
  duty.%end_day%) / 24:00 - 1 >= 2;
  
%duty_preceded_by_2_freedays_or_bought_days% =
  is_first(duty(wop)) or
  (duty.%start_day% -
   prev(duty(wop), duty.%end_day%) where
   (not duty.%is_bought%)) / 24:00 - 1 >= 2;
                       
/* SBY trips are converted to single leg pact trips at Publish. 
   We should warn when actual trips are too close together.
   Sby lines that are PACT should be checked only when next trip is another
   sby line, that is not a PACT, or when next trip is off duty.
   Sby lines that are not PACT should always be checked.
   */
%trip_is_sby_line_to_be_checked% =
  trip.%is_standby_line% and
  not next(trip(roster), trip.%is_fs%) and
  (not trip.%is_pact% or
   next(trip(roster), trip.%is_off_duty% or trip.%is_standby_line% and (not trip.%is_pact%)));

/****************************************************************
 * Section 2: Block time rules
 ***************************************************************/

/*
** Rule:
**    Max block time in calendar month
**
** Description:
**    Check that the total block time in a calendar month is less than max
**    allowed. The block time is reduced by part time factor and available days.
**    It is alid for FCLH and Japanese CC.
**
** Agreement:
**    K08.5 passage 6.3.6
**    SKJ
*/
rule ind_max_block_time_in_calendar_month_FC =
  valid roster.%check_rules% and
        crew.%is_long_haul_pp_start% and
        ((%flight_crew% and crew.%is_SKI%) or crew.%is_SKJ%) and
        trip.%in_pp% and
        trip.%is_last_on_duty_in_month_or_pp% and
        not crew.%is_leased_trip_start%;
        
  %block_time_calendar_month% <=
    %max_block_time_in_calendar_month% + 
		rule_exceptions.%overshoot_rel%(trip.%start_UTC%);
  startdate = trip.%start_UTC%;
  severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = %ind_max_block_time_in_calendar_month_FC_failboject%;
  failtext(Reltime value, Reltime limit) =
    rules.%failtext_rel%(format_time(trip.%start_month_start%,
                                     "Coll: Block time in %b"),value,limit);
  remark "Coll: Max block time in calendar month",
  planner "The rule checks that the total block time in a calendar month is less"
          " than maximum allowed. The block time is NOT reduced in any way"
          " by part-time factor or VA etc. SKI limit is 90 hours except"
          " for Jun, Jul and Aug where limit is 100 hours, SKJ limit is 88 hours."
          " Valid for SKI and SKJ CC.";
end

%ind_max_block_time_in_calendar_month_FC_failboject% =
  let month_start = trip.%start_month_start%,
      month_end = trip.%start_month_end%,
      overshoot = rule_exceptions.%overshoot_rel%(trip.%start_UTC%);
  last(leg(trip),
       prev(leg(chain),next(leg(chain),leg.%failobject_departure%)) where 
        (roster.%block_time_in_period%(month_start,leg.%end_hb%) <= 
         %max_block_time_in_calendar_month% +
         overshoot)) where
  (leg.%start_hb% < month_end);

%block_time_calendar_month% = 
  roster.%block_time_in_period%(crew.%utc_time%(trip.%start_month_start%), crew.%utc_time%(trip.%start_month_end%));

export %max_block_time_in_calendar_month% =
  %_max_block_time_in_calendar_month%;

set summer_months = "Jun", "Jul", "Aug";

%is_summer_month%(AbsTime tim) =
    format_time(tim, "%b") in summer_months;

table max_block_time_in_calendar_month =
    parameters.%k15_feb16_valid%(trip.%start_utc%), /* this is changed from jan to feb */
        crew.%has_agmt_group_ski_fd%,
            crew.%is_SKJ%,
                %flight_crew% and crew.%is_SKI%,
                    %is_summer_month%(trip.%start_month_start%) ->
                            %_max_block_time_in_calendar_month%;

    y,  y,  -,  -,  -   ->  900:00;
    y,  n,  y,  -,  -   ->   88:00;
    y,  n,  n,  -,  -   ->    0:00;
    n,  -,  -,  y,  y   ->  100:00;
    n,  -,  -,  y,  n   ->   90:00;
    n,  -,  y,  n,  -   ->   88:00;
    n,  -,  n,  n,  -   ->    0:00;
end

/****************************************************************
 * Section 3: Rest rules
 ***************************************************************/

/*
** Rule: 
**    Minimum rest after trip
** 
** Description:
**    The rule checks that the rest time at homebase is greater than the 
**    minimum rest time.
**
**    It is unnecessary to check the rule when ending at station, i.e. 
**    inside trips. This is instead checked in CCP.
**
**    If the trip is followed by a blank day the rest rule is not checked,
**    but when the BL-day is converted into production the rest limit will 
**    be checked.
**
** Agreement:
**    FC 1:10 F.1, 1:18 2.4a
**    CAU H.2.1.1, H.2.1.2
**    NKF 7
**    SCCA G.1.1, G.2.3
**
**    K11 FC - no longer valid SKD/SKN/SKS when active flight duty follows.
**
**    4ExNG - no longer applies for scandinavian crew when active flight duty follows.
*/
export rule ind_min_rest_after_trip_ALL =
  valid roster.%check_rules% and
        not crew.%is_leased_trip_start% and
        %trip_rest_end_in_pp_extended% and
        not trip.%has_agmt_group_fpu_cc% and
        trip.%is_on_duty% and
        not is_last(trip(wop)) and
        not trip.%is_rest% and
        not last(leg(trip), leg.%is_standby_callout%) and
        not trip.%is_sby_manual_duty_break% and
        not (last(duty(trip), duty.%is_bought% or
             next(duty(wop),duty.%is_bought%))) and        
       (not (trip.%is_ground_duty% and next(trip(wop), trip.%is_ground_duty%) and
             trip.%start_day% = next(trip(wop), trip.%start_day%)) or
            (training.%trip_is_in_school_period_min_7x24% and 
            (trip.%is_simulator% or trip.%has_school_flight%))) and
        not (%flight_crew% and
             not trip.%is_ski%  and
             next(trip(wop),first(duty(trip),duty.%has_active_flight%)));
  trip.%rest_time% >= rest.%trip_minimum_time_plan% -
                      rule_exceptions.%overshoot_rel%(trip.%end_UTC%);
          
  startdate = trip.%end_UTC%;
  severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = next(trip(roster), trip.%failobject_start%);
  failtext (Reltime value, Reltime limit) =
    rules.%failtext_rel%("Coll: Rest after trip", value, limit);
  remark "Coll: Min rest after trip",
  planner "The rule checks that the rest after each trip (i.e. at homebase) is"
          " at least as long as minimum required. The rule is not checked inside"
          " trips, this is done in the pairing construction phase. Min rest is"
          " 12hrs for all crew, but the limit is extended by 2hrs for SKD and SKN,"
          " if not tracking or between short-before-long duties. As well as for"
          " flight crew under education performing simulators or flying school trips.";
end

%trip_rest_end_in_pp_extended% =
    default(overlap(trip.%start_hb%,trip.%rest_end%,%pp_start%,%pp_end_extended%) > 0:00, false);

/* Note: Ugly fix, variables in module standby cannot be used since the 
 * module is only availble in CCT */
%trip_has_standby_callout% =
  any(leg(trip), leg.%is_standby%) and
  any(leg(trip), leg.%is_flight_duty% or leg.%is_ground_transport%);

/*
** Rule:
**    Night rest required before/after short stop
**
** Description:
**    The rule checks that the rest before and after a short stop
**    includes minimum night rest, i.e. min rest (8:00) + 1 * local transport
**    is in the interval [20:00,09:00].
**
**    It is only needed to check this rule if the trip has a short stop at
**    the beginning or the end of the trip. All other cases will be checked in CCP.
**
**    NB! Two implementations of this rule is done. One in CCP, checking rest btw
**    duties and one in CCR checking rest btw trips (if the trip starts or ends
**    with a short stop).
**
** Agreement:
**    FC 1:18 2.4b
**    CAU H.1.1.2
**    SCCA G.1.2
**
**    NB! Not valid for 4ExNG CC
*/
export rule ind_night_rest_surrounding_short_stop_FC_SKD_SKS =
  valid roster.%check_rules% and
        not crew.%k4exng_cc_sp5_1_valid%(trip.%start_day%) and
        not crew.%is_leased_trip_start% and
        %r_valid_night_rest_surrounding_short_stop% and
        (trip.%in_pp_extended% or trip.%rest_ends_in_pp%) and
        not trip.%is_single_leg_standby_callout% and
        not is_last(trip(wop)) and
        not next(trip(wop), trip.%is_rest%) and
        not next(trip(wop),first(duty(trip),duty.%is_bought% or
                 prev(duty(chain),duty.%is_bought%))) and
        (rest.%is_short_last_in_trip% or 
        next(trip(wop), rest.%is_short_first_in_trip%));
  rest.%trip_night_rest% >= rest.%trip_min_time_at_night% - 
		       rule_exceptions.%overshoot_rel%(trip.%start_UTC%);
  startdate  = trip.%start_UTC%;
  severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = next(trip(wop), trip.%failobject_start%);
  failtext(Reltime value, Reltime limit) =
    rules.%failtext_rel%(concat("Coll: Night rest ", 
           (if rest.%is_short_last_in_trip% then "after " else "before ")),
           value,limit);
  remark "(CCR) Coll: Min night rest surrounding short stop",
  planner "The rule checks that night rest before and after a short stop is"
          " at least 10hrs in the time interval (20:00, 09:00) local time at"
          " homebase. The rule is valid for all short haul qualified crew.";
end

/* Defined in child modules due to different validity for FC and CC. */
%r_valid_night_rest_surrounding_short_stop% = Bool;


/****************************************************************
 * Section 4: Freeday rules
 ***************************************************************/
 
/*
** Rule:
**    Min freedays before LA-days
**
** Description:
**    The rule checks that preassigned LA-days are preceded by at least
**    the number freedays as stated in the agreements.
**
** Agreement:
**    FC F-days before LA: 6.1.15.1
*/

export rule ind_min_freedays_before_LA_days_ALL =
  valid roster.%check_rules% and 
        not crew.%is_leased_wop_start% and
        not (crew.%is_skd% and crew.%is_temporary%) and
        %is_valid_min_freedays_before_LA_days% and
        wop.%starts_in_pp% and
        wop.%is_la% and
        not %is_short_notice_la% and
        rule_exceptions.%rule_on%(wop.%start_UTC%);
        
  first(duty(wop),freedays.%off_duty_days_before_wop%) >=
    freedays.%min_freedays_before_LA%;
  
  startdate  = wop.%start_utc%;
  severity = first(leg(wop), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = wop.%failobject_start%;
  failtext(Int value, Int limit) =
    rules.%failtext_int%("Coll: F-days before LA", value, limit);
  remark "Coll: Min freedays before LA-days",
  planner "Check that the number of freedays before preassigned (or assigned"
          " tasks) LA-days is at least what is stated in the agreements";
end

/*  The list of codes is from WP L 356 
**  Short notice LA days are only used in CCT so %is_short_notice_la% must
**  evaluate to false in CCR (WP FAT LEG #80)*/
set short_notice_la_codes = "LA91", "LA91R", "LA92", "LA92R",
                            "LA42", "LA66", "LA64", "LA33";
%is_short_notice_la% =
  %product% = "CCT" and
  first(leg(wop), task.%code% in short_notice_la_codes);

%is_valid_min_freedays_before_LA_days% =
  %cabin_crew% or
  (parameters.%k11_fc_sp3_2_valid%(%pp_start%) and
   not crew.%is_ski% and
   prev(wop(roster),freedays.%wop_days% > 4)
     where (wop.%is_on_duty%));  
  
/*
** Rule:
**    Min number of freedays after production.
**
** Description:
**   Checks that the number of freedays scheduled after production is at
**   least the number required according to the number of production days.
**   Cimber CC and FD are excluded from this rule SKCMS-607
**   
**   
** Agreement:
**    FC 1:11 G, 13:46 8,
**    CAU J.1.1, J.2.1, L.2, P
**    NKF Ammendment, 8
**    SCCA H, H.2.2
*/
rule ind_min_freedays_after_duty_ALL =
    valid %ind_min_freedays_after_duty_ALL_valid%;

    freedays.%freedays_after_duty% >=
        freedays.%min_required_freedays_after_duty_total% - rule_exceptions.%overshoot_int%(duty.%start_utc%);
                           
    startdate  = duty.%start_UTC%;
    severity = %ind_min_freedays_after_duty_ALL_severity%;

    failobject = %ind_min_freedays_after_duty_ALL_failobject%;
    failtext(Int value, Int limit) =
        freedays.%min_required_freedays_after_duty_failtext%(value, limit);
    remark "Coll: Min freedays after production",
    planner "Check that the number of freedays after scheduled production is "
            "at least the number required according to the number of production "
            "days.";
end

%ind_min_freedays_after_duty_ALL_severity% =
    if %ind_min_freedays_after_alert% then
       first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%))
    else
        %severity_filter_ignorable%;

export %ind_min_freedays_after_alert% =
 /* a "toggle" to turn on/off the _alert variant, and at the same time control the non-alert variant.
    Here we test to see if we can find any more on-duties withing a published period.
    Is also used in .._fc and .._cc
    */

    let next_on_duty_start =
        default(
            next(trip(roster), trip.%start_day%)
            where (trip.%is_on_duty%)
            , base_calendar.%month_end%(trip.%start_day%)  + 24:00 /* a date in the beginning of the next month */

            );
    calendar.%is_in_published_period%(next_on_duty_start);

%lw_check_failtext% =
  freedays.%min_required_freedays_after_duty_failtext%(1, 2);

export %ind_min_freedays_after_duty_ALL_valid% =
    not %next_duty_not_LOA100_ind_min_freedays_surrounding_summer_vacation_valid% and
    not %ind_min_lh_rest_hours_after_first_valid% and
    not %ind_min_lh_rest_days_after_second_valid% and
    %_ind_min_freedays_after_duty_ALL_valid%;

%_ind_min_freedays_after_duty_ALL_valid% =
    roster.%check_rules% 
and freedays.%valid_freedays_after_duty%
and not (crew.%is_skd% and crew.%is_temporary% and
         (not crew.%k4exng_cc_sp5_1_valid%(%pp_start%) or
          freedays.%wop_days% <> 5))
and not (crew.%is_skd% and duty.%is_standby_line% and
         not duty.%is_last_in_standby_line%)
and not crew.%is_skk%
and crew.%in_variable_group_duty_end%
and not crew.%is_leased_duty_start%;

%ind_min_freedays_after_duty_ALL_failobject% =
    default(
        if not duty.%consecutive_duties_fw% then
            last(leg(duty), leg.%failobject_departure%)
        else
            next(duty(chain) 
            where (not duty.%is_freeday% or not duty.%is_off_duty_cmp% or
                   (duty.%is_bought% and bought_days.%duty_bought_type% <> "F") or
                   not duty.%consecutive_duties_fw%), duty.%failobject_start%)
        , duty.%failobject_start%);

export %next_duty_not_LOA100_ind_min_freedays_surrounding_summer_vacation_valid% =
        /* ensure that this rule is not applied if the new rule is applied the next duty that is not LOA100 */
  default(next(duty(roster), %ind_min_freedays_surrounding_summer_vacation_valid%)
          where (not (duty.%is_freeday% or duty.%is_illness% or freedays.%duty_is_LOA%)),
  false);

%ind_min_freedays_surrounding_summer_vacation_valid% =
    let start_day = duty.%start_day%;
    is_first(duty(wop)) and
    crew.%in_variable_group_at_date%(start_day) and
    freedays.%freedays_surrounding_summer_vacation_group_at_date%(start_day) and
    freedays.%is_summer_vacation%(false) and 
    freedays.%count_summer_vacation_days_from_date%(wop.%start_day%) = %ind_check_out_before_summer_va_num_va_days%;

/*
** Rule:
**    Min number of rest hours after long haul production for FD.
**
** Description:
**   Checks that the number of hours scheduled after long haul production is at
**   least the minimum hours. This rule is valid for all FD with LH duty.
**   Crew with a mix of SH and LH in their wop is exempted.
     SKCMS-651, SKCMS-2760, SKCMS-2923, SKCMS-3081
**
** Level: Trip
**
** Agreement:
**
*/

export rule (on) ind_min_lh_rest_hours_after_first =
    valid %ind_min_lh_rest_hours_after_first_valid%;

    trip.%planned_rest_time% >= %min_rest_hours_after_first_lh% - rule_exceptions.%overshoot_rel%(trip.%start_UTC%);

    startdate = next(trip(chain), trip.%start_hb%);
    severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
    failobject = next(trip(chain), trip.%failobject_start%);
    failtext %ind_min_lh_rest_hours_after_first_failtext%;

    remark "Coll: Min rest hours after long haul production",
    planner "Check that the number of hours after this scheduled production is at least 72:00 hours."
            "Or minimum 3 days if wop is a mix of SH and LH.";
end

%ind_min_lh_rest_hours_after_first_valid% =
    trip.%in_pp_extended_start_5d_before% and
    last(duty(trip), %min_rest_time_after_lh_valid%) and
    not wop.%is_SH_LH%;

%min_rest_hours_after_first_lh% = 
    if %trip_is_preceded_by_SH_not_bought% 
        then %min_free_mff_sh_lh_mix%
     else 72:00;

%min_free_mff_sh_lh_mix% =
    72:00 + (24:00 - trip.%end_od%);

%trip_is_preceded_by_SH_not_bought% =
  default(prev(trip(wop), %_trip_is_SH_not_bought%), false);

%_trip_is_SH_not_bought% =
  trip.%is_short_haul% and
  not trip.%is_bought%;

%ind_min_lh_rest_hours_after_first_failtext% =
    let value_days = %rest_day_after_duty%,
        limit_days = %min_rest_days_after_second_lh%,
        value = trip.%planned_rest_time%,
        limit = %min_rest_hours_after_first_lh%;
     if %trip_is_preceded_by_SH_not_bought% then
            rules.%failtext_int%("Coll: Min. rest days after LH ",value_days, limit_days)
        else rules.%failtext_rel%("Coll: Min. rest hours after LH ", value, limit);

/*
** Rule:
**    Min number of rest days after second long haul production for FD.
**
** Description:
**   If wop is a mix of SH and LH then 3 F are required.
**   Or check previous long haul production before this long haul production; if the previous
**   long haul production had less than minimum amount of rest days then rule checks the
**   number of second rest days against minimum amount of rest days.
**
**   __LH__, __FIRST_REST__, ....., __LH__, __SECOND_REST__
**   (if __FIRST_REST__ < min.rest.days then __SECOND_REST__ >= min.rest.days)
**
**   This rule is valid for all FD on LH duty. 
**   SKCMS-651, SKCMS-2760, SKCMS-2923, SKCMS-3081
**
** Level: Trip
**
** Agreement:
**
*/
export rule (on) ind_min_lh_rest_days_after_second =
    valid %ind_min_lh_rest_days_after_second_valid%;

    %rest_day_after_duty% >= %min_rest_days_after_second_lh% - rule_exceptions.%overshoot_int%(trip.%start_utc%);

    startdate = next(trip(chain), trip.%start_hb%);
    severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
    failobject = next(trip(chain), trip.%failobject_start%);

    failtext(Int value, Int limit) = rules.%failtext_int%("Coll: Min. rest days after LH ",value, limit);

    remark "Coll: Min rest days after long haul production",
    planner "Check that the number of rest days after this scheduled production is at least 3 days. "
            "Also check that this scheduled production is preceded with long haul production that has less than 3 days rest  ";
end

%ind_min_lh_rest_days_after_second_valid% =
    trip.%in_pp_extended_start_5d_before% and
    last(duty(trip), %min_rest_time_after_lh_valid%) and
    (%is_preceded_with_long_haul_trip_with_less_than_min_rest_days% or wop.%is_SH_LH%);

%min_rest_days_after_second_lh% = 3;

/* Level: Duty */
export %min_rest_time_after_lh_valid% =
    roster.%check_rules% and
    %FD_on_LH_duty_not_east_west% and
    duty.%has_active_long_haul%;

/* Level: Trip */
export %rest_day_after_duty% =
   /* This condition should handle void trip.%rest_end% in simple and efficient way */
        if trip.%planned_rest_time% > ((%min_rest_days_after_second_lh% + 1) * 24:00) then
            %min_rest_days_after_second_lh%
        else
            trip.%planned_rest_days%;
        /*(round_down(trip.%rest_end%, 24:00) - round_up(trip.%end_hb%, 24:00)) / 24:00;*/


export %is_preceded_with_long_haul_trip_with_less_than_min_rest_days% =
    default(prev(wop(chain) where(wop.%has_production%),
            (wop.%has_active_long_haul% and last(trip(wop),%rest_day_after_duty% < %min_rest_days_after_second_lh%)))
            ,false);

export %ind_min_lh_rest_failobject% =
    let first_rest_end = next(duty(chain),
            if duty.%is_rest% then duty.%end_hb%
            /* If duty is not rest, there should be a gap (empty space) and the end of the rest is start of the next duty */
            else duty.%start_hb% - 00:01);
    if base_product.%is_tracking% then
        next(trip(chain), trip.%failobject_start%)
    else
        next(duty(chain)
        where (duty.%start_hb% > first_rest_end and duty.%is_rest%), duty.%failobject_start%);

%FD_on_LH_duty_not_east_west% =
    %FD_on_LH_duty% and not freedays.%east_to_west_or_west_to_east%;

%FD_on_LH_duty% =
    (duty.%is_SKI% or duty.%is_long_haul%) and
    fundamental.%flight_crew%;


/*
** Rule:
**    Min freedays before vacation
**
** Description:
**    The rule checks that the VA-days are placed in the required 
**    pattern. VA-days are to be preceded by two freedays unless flight
**    crew have summer vacation or VA period is less than 7 days long..
**
** Agreement:
**    FC 9:1 Mom6
**    CAU J.1.1.2e, J.2.1.6
**    NKF VA: Bilag C
**    SCCA �4 mom2
**    K22 FD 8.3.1.2 (SKCMS-3147)
*/

export rule ind_min_freedays_in_cnx_with_VA_ALL =
  valid %ind_min_freedays_in_cnx_with_VA_ALL_valid%;

  freedays.%nr_before_VA% >= freedays.%min_before_VA% -  rule_exceptions.%overshoot_int%(wop.%start_UTC%);

  startdate  = wop.%start_UTC%;
  severity = first(leg(wop), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = wop.%failobject_start%;
  failtext(Int value, Int limit) =
    rules.%failtext_int%(concat("Coll: F-days ",
           if freedays.%wop_is_summer_vacation%
           then
             if crew.%is_fc_no% then "before" else "around"
           else "before",
           " VA (cnx)"), value, limit);
  remark "Coll: Min freedays in connection with vacation",
  planner "Check that the scheduling of VA-days is correct according"
          " to agreements CAU J.1.1 and FC 9:1 Mom6. VA-days are to be preceded"
          " by two freedays if it is not summer vacation. If summer vacation"
          " and flight crew it must be surrounded by 4 freedays."
           "If VA period is shorter than 7 days no F days before is required";
end


export %ind_min_freedays_in_cnx_with_VA_ALL_valid% =
    not %ind_min_freedays_surrounding_summer_vacation_valid% and
    roster.%check_rules% and
    not crew.%is_leased_wop_start% and
    wop.%is_vacation% and
    not crew.%is_svs_at_trip_start% and
    wop.%starts_in_pp% and
    is_first(duty(wop)) and
    %r_valid_min_freedays_in_cnx_with_VA% and
    not (crew.%is_skd% and crew.%is_temporary%) and
    crew.%in_variable_group_wop_start%;


/* Defined in child modules due to different validity */
%r_valid_min_freedays_in_cnx_with_VA% = Bool;

/*
** Rule:
**    Check the check-in time after days off
**
** Description:
**    Checks that the check-in time on the first duty after days off
**    is later than earliest allowed.
**    The limits are defined in a table, thus all new limits and
**    cases shall be entered in the table
**    Rule valid for both LH and SH.
**
** Agreement:
**    FC 1:2 Mom 3, 1:11G.1
**    CAU K06 L.1
**    K22 FD - new weekend definition requires no check-in limitation (SKCMS-3156)
*/
export rule ind_check_in_time_limit_for_wop_ALL =
  valid %ind_check_in_time_limit_for_wop_ALL_valid%;
        
  %start_of_ci% >= %check_in_time_limit% - 
		    rule_exceptions.%overshoot_rel%(wop.%rest_end_before_utc%);
  startdate  = wop.%rest_end_before_utc%;
  severity = first(leg(wop), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = first(trip(wop), trip.%failobject_start%) where (not trip.%is_rest%);
  failtext(Reltime value, Reltime limit) = 
    rules.%failtext_rel%(
                         concat("Coll: C/I after ", %check_in_limitation_type%),
                         value, limit);
  remark "(CCR) Coll: No early check in after days off",
  planner "The rule checks that the check in time on the first duty"
          " after days off is later than the earliest allowed."
          " The rule is valid for FC and CC.";
end

export %ind_check_in_time_limit_for_wop_ALL_valid% =
  roster.%check_rules% and
  not crew.%is_leased_wop_start% and
  wop.%starts_in_pp% and
  wop.%is_on_duty% and
  not trip.%has_agmt_group_fpu_cc% and
  not (crew.%in_5_4_flex_group%(wop.%start_hb%) and not prev(wop(chain), wop.%is_vacation%)) and
  first(trip(wop), not (trip.%is_blank_day% or trip.%is_gnd%)) and
  not first(duty(wop),duty.%is_bought%) and
  %r_valid_check_in% and
  (wop.%start_utc% - %r_comparative_check_out% < 24:00);

%start_of_ci% = first(trip(wop),trip.%start_od%) where (not trip.%is_rest%);
%ci_start_day_of_week% =
  fundamental.%day_of_week%(first(trip(wop),trip.%start_day%)
                              where (not trip.%is_rest%));
%r_valid_check_in% = %_r_valid_check_in%(%ci_limitation_type_ix%);
%r_comparative_check_out% = %_r_comparative_check_out%(%ci_limitation_type_ix%);
%ci_limitation_type_ix% = default(first(times(%check_in_time_limitations_max%), %times_index_0%) where (%_r_valid_check_in%(%times_index_0%)), 0);

/*
  pleaes note that the logic uses the first limit found, when _r_valid_check_in is true, so the order is important.
  It would have been more secure to use the most limiting condition, in cases where the most limiting is not obvious
*/

table check_in_time_limitations(Int ix) =
  %flight_crew%, crew.%region%, ix ->
    %_r_valid_check_in%,
    %_r_comparative_check_out%, /* if c/i limit is NOT controlled after a certain block on roster (e.g. VA block) then wop.%start_utc% should be used.... Freedays are not on roster in optimization, they are just empty days */
    %_check_in_time_limit%,  /* hb times! */
    %_check_in_limitation_type%;
  
  
  /* Flight crew */
  true, <>"SKI",1 -> crew.%in_variable_group_wop_start% and
                     not crew.%has_agmt_group_fpu_fd% and
                     not training.%wop_is_in_school_period_min_7x24% and
                     %has_check_in_limitation_after_2_freedays%,
                     wop.%start_utc%,
                     %ci_limit_after_2F%,
                     "2 freedays";
  true,     - , 2 -> crew.%has_rotationsferie_contract_SKN_FD_at_date%(round_down(wop.%start_hb%, 24:00) - 14 * 24:00) and
                     not first(trip(wop), trip.%is_compensation_day%) and
                     not first(duty(wop), duty.%is_privately_traded%) and
                     %_rotationsferie_ci_valid%,
                     prev(wop(roster), wop.%end_utc%),
                     6:00,
                     "summer rotationsferie";
  true, "SKS" , 3 -> freedays.%prev_not_freedays_wop_was_vacation% and
                     freedays.%vacation_days% >= 7,
                     prev(wop(roster), wop.%end_utc%) where(wop.%is_vacation%),
                     06:00,
                     "vacation";
  true, "SKN" , 4 -> freedays.%prev_not_freedays_wop_was_vacation% and
                     freedays.%vacation_days% >= 6,
                     prev(wop(roster), wop.%end_utc%) where(wop.%is_vacation%),
                     07:00,
                     "vacation";
  true,    -,   5 -> training.%wop_is_in_school_period_min_7x24%,
                     wop.%start_utc%,
                     06:00,
                     "training";
  true,    -,   6 -> freedays.%previous_wop_is_isolated_FS%,
                     prev(wop(roster), wop.%end_utc%),
                     08:00,
                     "isolated FS";

  /* Cabin crew */
  false, "SKD", 7 -> first(leg(wop),leg.%is_standby_with_rest%) where (not leg.%is_rest%)
                     and freedays.%prev_not_freedays_wop_was_vacation% and
                     freedays.%vacation_days% >= 7
                     and system_db_parameters.%skd_cc_cau_nov2016%(wop.%start_hb%),
                     prev(wop(roster), wop.%end_utc%),
                     04:40,
                     "vacation"; 
  false,"SKD", 8 -> freedays.%prev_not_freedays_wop_was_vacation% and
                     freedays.%vacation_days% >= 7
                     and system_db_parameters.%skd_cc_cau_nov2016%(wop.%start_hb%),
                     prev(wop(roster), wop.%end_utc%),
                     06:00,
                     "vacation";
  false,   -,   9 -> crew.%in_variable_group_wop_start% and
                     %cabin_crew% and
                     not crew.%has_agmt_group_skn_cc% and
                     wop.%is_preceded_by_F4% and
                     %ci_start_day_of_week% = 1,
                     prev(wop(roster), wop.%end_utc%),
                     freedays.%free_we_earliest_end%,
                     "F4";
  false, "SKD",10 -> %has_check_in_limitation_after_2_freedays%,
                     wop.%start_utc%,
                     08:00,
                     "LH charter with 2 freedays";
  false,"SKN", 11 -> first(leg(wop),leg.%is_standby_with_rest%) where (not leg.%is_rest%)
                     and freedays.%prev_not_freedays_wop_was_vacation% and
                     freedays.%vacation_days% >= 7
                     and system_db_parameters.%skn_cc_oct2016_valid%(wop.%start_hb%),
                     prev(wop(roster), wop.%end_utc%),
                     04:20,
                     "vacation";
  false,"SKN", 12 -> freedays.%prev_not_freedays_wop_was_vacation% and
                     freedays.%vacation_days% >= 7
                     and system_db_parameters.%skn_cc_oct2016_valid%(wop.%start_hb%),
                     prev(wop(roster), wop.%end_utc%),
                     06:00,
                     "vacation";
  false,"SKS", 13 -> default(is_first(trip(wop))
                         where (not trip.%is_rest%)
                         and not first(trip(wop), trip.%is_rest%)
                         and freedays.%prev_wop_is_vacation_with_no_freedays%
                         and freedays.%vacation_days% >= 5
                         and system_db_parameters.%scca_engagement_2019%(wop.%start_hb%),
                    false),
                    prev(wop(roster), wop.%end_utc%),
                    06:00,
                    "vacation";  
  /* Default */
  -, -, - -> false, prev(wop(roster), wop.%end_utc%), 0:00, "UNKNOWN";
end
export %check_in_time_limitations_max% = 20;

/*
** For short-haul FC, check-in after F4 weekends must always be checked, but 
** weekends with other acceptable activities should only be checked if there is 
** no legal free weekend in the month.
**    K22 FD -  new free weekend definition requires no check-in limitation
*/
%check_wop_preceded_by_activity_allowed_on_weekend_fcsh% =
    let fw_in_period = freedays.%has_free_weekend_in_period_by_date%(trip.%start_month_start%);
    not default(
      next(wop(roster), 
        first(trip(wop), fw_in_period)
        where (freedays.%trip_is_last_not_free_we_in_month%))
      where (
        any(trip(wop),
          trip.%start_month_start% = round_down_month(%pp_start%)
            and freedays.%trip_is_last_not_free_we_in_month%))
    ,
      last(trip(wop), fw_in_period)
    )
    and wop.%is_preceded_by_activity_allowed_on_weekend_fcsh%
    and any(times(freedays.%free_we_interval_max_number_of_types%),
        (time_of_week(wop.%start_day%) <= freedays.%free_we_end_tow%(%times_index_0%)
        and freedays.%free_we_end_tow%(%times_index_0%) - time_of_week(wop.%start_day%) <= 24:00));

/* Defined in child modules due to different values */
%_ci_limitation_after_2F% = Bool;

%_co_limitation_before_2F% = wop.%start_od% < %ci_limit_after_2F%;

/* The following is redefined for FC */
%ci_limit_after_2F% = 8:00;

%has_check_in_limitation_after_2_freedays% =
  freedays.%wop_after_2_freedays% and
  first(trip(wop), not trip.%is_long_haul%) where (trip.%has_active_flight%) and
  prev(wop(roster),not last(trip(wop),trip.%has_no_duty_time_contribution%) and
                   %_ci_limitation_after_2F%)
  where (not wop.%is_freeday%);

%has_check_out_limitation_before_2_freedays% =
  freedays.%wop_followed_by_2_freedays% and
  next(wop(roster),not first(trip(wop),trip.%has_no_duty_time_contribution%) and
                   %_co_limitation_before_2F%)
  where (not wop.%is_freeday%);

%check_in_time_limit% = %_check_in_time_limit%(%ci_limitation_type_ix%);
%check_in_limitation_type% = %_check_in_limitation_type%(%ci_limitation_type_ix%);

/*
** Rule:
**    SKCMS-884
**    Check the check-out time before summer vacation (2016)
**
** Description:
**    Checks that the check-out time bfore summer vacation is before 19:00
**    Valid for SKN-FD_AG, SKS-FD_AG, SKIN-FD-AG, SKIS-FD-AG
**    If vacation period which includes LA days, LOA days and F days together
**    with summer vacation VA days (starts earliest 30May bad ends latest 04sepo
**   is exactly 21 days then the checout time must be before 19:00
**
*/
export rule ind_check_out_before_summer_va =
  valid roster.%check_rules%
  and  is_first(duty(wop))
  and  duty.%in_pp%  
  and  not crew.%is_leased_wop_start%
  and  crew.%in_variable_group_at_date%(duty.%start_day%)
  and  %ind_check_out_before_summer_va_agmt_groups_valid%
  and  freedays.%is_summer_vacation%(true)
  and  freedays.%count_summer_vacation_days_from_date%(wop.%start_day%) = %ind_check_out_before_summer_va_num_va_days%
  and  not default(prev(duty(roster),duty.%is_loa%),true)
  and  %co_time_within_x_days_before_vacation%;
    %co_before_summer_vac%<=
    %check_out_time_limit_summer_va% + 
		rule_exceptions.%overshoot_rel%(prev(duty(roster),duty.%end_UTC%) where (duty.%is_on_duty%));
  startdate  =  prev(duty(roster),duty.%end_UTC%) where (duty.%is_on_duty%); 

  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = %ind_check_out_before_summer_va_failobject%;

  failtext "CCR : Checkout too late before summer vacation";
  remark "(CCR) Coll: No late check out before summer vacation",
  planner "The rule checks that the check out time for the last duty"
          "before summer vacations";
end
%ind_check_out_before_summer_va_agmt_groups_valid% =
    crew.%has_agmt_group_skis_fd_at_date%(duty.%start_utc%) or
    crew.%has_agmt_group_sks_fd_at_date%(duty.%start_utc%) or
    crew.%has_agmt_group_skin_fd_at_date%(duty.%start_utc%) or
    crew.%has_agmt_group_skn_fd_at_date%(duty.%start_utc%) or
    crew.%has_agmt_group_skn_cc_at_date%(duty.%start_utc%);

%ind_check_out_before_summer_va_num_va_days% =
    if crew.%has_agmt_group_skn_cc_at_date%(duty.%start_utc%) then
      19
    else
      18;
 
%co_time_within_x_days_before_vacation% =
  default(round_down(prev(duty(roster),duty.%end_hb%)
		   where (duty.%is_on_duty% and not duty.%is_compensation_day%),
		   24:00) >= round_down(duty.%start_hb% + 0:01,24:00) - (21 - %ind_check_out_before_summer_va_num_va_days% + 1)*24:00,
           false);

/* We suppress 0:00 values here, replacing them with 24:00. This allows us to
** compare the value to the limit in the ind_check_out_before_summer_va rule */
%co_before_summer_vac% = 
  prev(duty(roster), if time_of_day(duty.%end_hb%) = 0:00 then 24:00 else time_of_day(duty.%end_hb%))
      where (duty.%is_on_duty% and not duty.%is_compensation_day%);
    
%check_out_time_limit_summer_va% = 19:00;

%ind_check_out_before_summer_va_failobject% = 
   prev(duty(roster),duty.%failobject_end%)
      where (duty.%is_on_duty%);



/*
** Rule:
**    Check the check-out time before days off
**
** Description:
**    Checks that the check-out time for the last duty before days off
**    is earlier than latest allowed.
**    The limits are defined in a table, thus all new limits and
**    cases shall be entered in the table
**
** Agreement:
**    CAU check-out before F-days: J.1
**    K22 FD - new weekend definition requires no check-out limitation (SKCMS-3156)
*/
export rule ind_check_out_time_limit_for_wop_ALL =
  valid %ind_check_out_time_limit_for_wop_ALL_valid%;

  %planned_check_out% <=
    %check_out_time_limit% + 
		rule_exceptions.%overshoot_rel%(wop.%end_UTC%);

  startdate  = wop.%end_UTC%;
  severity = first(leg(wop), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = wop.%failobject_end%;
  failtext(Reltime value, Reltime limit) =
  rules.%failtext_rel%(concat("Coll: C/O before ", %check_out_limitation_type%),
         value, limit);
  remark "(CCR) Coll: No late check out before days off",
  planner "The rule checks that the check out time for the last duty"
          " before days off is earlier than the latest allowed.";
end

export %ind_check_out_time_limit_for_wop_ALL_valid% =
  roster.%check_rules% and
  not crew.%is_leased_wop_start% and
  not (crew.%is_skd% and crew.%is_temporary%) and
  wop.%in_pp% and
  wop.%is_on_duty% and
  not last(duty(wop), duty.%is_bought%) and
  %r_valid_check_out%;


/* Simple handling of midnight problem */
export %planned_check_out% =
    /* check the midnight check out time and see if last leg before FW is not free like VAC, LOA, ...  */
    /* for example VAC FW FW is acceptable even if the check out time is 0:00 so does not meet the if statement */
    if (%co_limitation_type_ix% = 2
        or %co_limitation_type_ix% = 7)
       and %_planned_check_out% = 0:00
       and last(leg(wop), task.%category_code% <> "OFF") then
        24:00
    else
        %_planned_check_out%;

%_planned_check_out% =
  if %product% ="CCT" and
     (parameters.%k4exng_fc_sp5_1_valid%(wop.%end_day%) or
      crew.%k4exng_cc_sp5_1_valid%(wop.%end_day%) or
      (%flight_crew% and crew.%is_skn%)) then
    time_of_day(%last_leg_wop_scheduled_end_time_hb%)
  else
    wop.%end_od%;

%last_leg_wop_scheduled_end_time_hb% = 
  last(leg(wop), leg.%co_end_scheduled_hb%);


%r_valid_check_out% = %_r_valid_check_out%(%co_limitation_type_ix%);
%co_limitation_type_ix% =
  default(first(times(10), %times_index_0%) where (%_r_valid_check_out%(%times_index_0%)), 0);

table check_out_time_limitations(Int ix) =
  %flight_crew%, crew.%region%, ix ->
    %_r_valid_check_out%,
    %_check_out_time_limit%, /* hb times! */
    %_check_out_limitation_type%;
  
  /* Flight crew */
  true, <>"SKI", 1 -> crew.%in_variable_group_wop_end% and
                      not crew.%has_agmt_group_fpu_fd% and
                      not training.%wop_is_in_school_period_min_7x24% and
                      %has_check_out_limitation_before_2_freedays%,
                      %co_limit_before_2F%,
                      "2 freedays";
  true,    -,   2 -> training.%wop_is_in_school_period_min_7x24%,
                     23:59,
                     "training";
  true,    -,   3 -> freedays.%next_wop_is_isolated_FS%,
                     22:00,
                     "isolated FS";

  /* Cabin crew */
  false, "SKD", 4 -> %next_wop_is_F7S%,
                     24:00,
                     "F7S";
  false, "SKS", 5 -> %next_wop_is_F7S%,
                     23:59,
                     "F7S";
  false,    -, 6 -> crew.%in_variable_group_wop_end% and
                    %cabin_crew% and
                    wop.%is_followed_by_F4% and not %F4_greenland_exception%,
                    freedays.%free_we_latest_start%,
                    "F4";
  false,"SKS", 7 -> default(crew.%in_variable_group_at_date%(wop.%start_hb%)
                             and is_last(trip(wop))
                             and freedays.%next_not_freedays_wop_is_vacation%
                             and wop.%freedays% = freedays.%min_before_VA%
                             and freedays.%following_vacation_days% >= 5
                             and system_db_parameters.%scca_engagement_2019%(wop.%start_hb%),
                    false),
                    18:00,
                    "vacation";

  /* Default */
  -, -, - -> false, 23:59, "UNKNOWN";
end

/*
** For short-haul FC, check-out before F4 weekends must always be checked, but 
** weekends with other acceptable activities should only be checked if there is 
** no legal free weekend in the month.
**    K22 FD -  new free weekend definition requires no check-out limitation
*/
%check_wop_followed_by_activity_allowed_on_weekend_fcsh% =
    let fw_in_period = freedays.%has_free_weekend_in_period_by_date%(trip.%start_month_start%);
    not next(wop(roster),last(trip(wop),fw_in_period)
                         where (freedays.%trip_is_last_not_free_we_in_month%))
             where (any(trip(wop),trip.%start_month_start% = round_down_month(%pp_start%) and
                                  freedays.%trip_is_last_not_free_we_in_month%)) and
    wop.%is_followed_by_activity_allowed_on_weekend_fcsh% and
    any(times(freedays.%free_we_interval_max_number_of_types%),
        (time_of_week(wop.%end_day%) < freedays.%free_we_start_tow%(%times_index_0%) and
        freedays.%free_we_start_tow%(%times_index_0%) - time_of_week(wop.%end_day%) <= 24:00));

/* N274 */
%F4_greenland_exception% =
  %cabin_crew% and crew.%is_SKD% and
  (freedays.%nr_of_one_day_greenland_return_in_wop% = 1 and
   freedays.%freedays_after_wop% = 3
   or
   freedays.%nr_of_one_day_greenland_return_in_wop% = 2 and
   freedays.%freedays_after_wop% = 4);

%next_wop_is_F7S% =
  default(next(wop(roster), wop.%is_F7S%), false) and
  wop.%end_day% + 24:00 = next(wop(roster), wop.%start_day%);

%last_trip_is_long_haul_charter% =
  last(trip(wop), trip.%is_long_haul_charter_skd%);

export %check_out_time_limit% = %_check_out_time_limit%(%co_limitation_type_ix%);
%check_out_limitation_type% = %_check_out_limitation_type%(%co_limitation_type_ix%);

/* The following is redefined for FC */
%co_limit_before_2F% = 20:00;

/*
** Rule:
**    SKCMS-1680
**    Check the check-out time before a "rotationsferie" within 01Jun-31Aug
**
** Description:
**    Checks that the check-out time for the last duty before summer rotationsferie is earlier than 19:00.
**    Rule valid for SKN_FD.
**
*/
export rule (on) ind_check_out_time_limit_before_summer_rotationsferie_SKN_FC =
  valid roster.%check_rules% and
        not crew.%is_leased_wop_start% and
        crew.%has_rotationsferie_contract_SKN_FD_at_date%(round_up(wop.%end_hb%, 24:00)) and
        wop.%in_pp% and
        (wop.%is_on_duty% and
         not last(trip(wop), trip.%is_compensation_day%)) and
        not last(duty(wop), duty.%is_bought% or duty.%is_privately_traded%) and
        %_rotationsferie_co_valid%;

  %_planned_check_out_before_summer_rotationsferie% <= 19:00 + rule_exceptions.%overshoot_rel%(wop.%end_UTC%);

  startdate  = wop.%end_UTC%;
  severity = first(leg(wop), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = wop.%failobject_end%;
  failtext(Reltime value, Reltime limit) =
  rules.%failtext_rel%("Coll: C/O before summer rotationsferie",
                       value, limit);
  remark "(CCR) Coll: No late check out before summer rotationsferie (SKN_FD)",
  planner "The rule checks that the check out time for the last duty"
          " before a summer rotationsferie is earlier than 19:00."
          " The rule is valid for SKN_FD.";
end

%_next_accumulated_rotationsferie_start% = accumulators.%rotationsferie_start%(wop.%start_hb%, True);
%_prev_accumulated_rotationsferie_end% = accumulators.%rotationsferie_end%(wop.%start_hb%, False);
%_wop_end_rounded_up% = round_up(wop.%end_hb%, 24:00);
%_wop_start_rounded_down% = round_down(wop.%start_hb%, 24:00);

%_rotationsferie_co_valid% =
   default(%_next_accumulated_rotationsferie_start% = %_wop_end_rounded_up%,
           False);

%_rotationsferie_ci_valid% =
   default(%_prev_accumulated_rotationsferie_end% = %_wop_start_rounded_down%,
           False);

%_planned_check_out_before_summer_rotationsferie% =
  if %_planned_check_out% = 0:00 then
    24:00
  else
    %_planned_check_out%;

/*
** Rule:
**    Min number of freedays in calendar month.
**
** Description:
**    Checks that VG crew is scheduled at least the minimum number of free 
**    days required in a calendar month. This is according to nr available
**    days and part time factor.
**    For everybody but FC VG SH this rule treats ordinary freeday and
**    (potential) parttimefreedays as a single reducable monthly freeday
**    requirement.
**    FC VG SH parttime crew freeday has unique calculation algorithm and
**    is checked through this rule, but differs slightly. 
**
** Agreement:
**    FC 1:18 2.5c, 13:46 8, SKI K06 ???
**    CAU J.1.1.1, P
**    NKF 3, 8
**    SCCA H.1.1
**
** NOTE:
**   Resource constraint for CG for this rule is defined in cg_model
**
*/
%some_vg_pre_fdc15% =
  if system_db_parameters.%fdc15_final_valid%(wop.%start_month_start%) then 
     model_freedays.%crew_any_vg_pre_fdc15_in_period%(crew.%id%, wop.%start_month_start%, wop.%start_month_end%)  
  else crew.%has_some_variable_group_in_month%;

export rule ind_min_freedays_in_1_month_ALL =
  valid roster.%check_rules% and
        not crew.%is_leased_wop_start% and
        not (crew.%has_agmt_group_skd% and crew.%is_temporary%) and
        not model_crew.%is_crew_monthly_parttime_at_date%(crew.%id%, wop.%start_month_start%) and
        wop.%start_month_start% = pp.%start_month% and
        wop.%start_hb% <= %pp_end% and
        %some_vg_pre_fdc15% and
        wop.%is_last_on_duty_in_month% and
        %r_valid_freedays_in_1_month%;
  freedays.%nr_qualifying_in_1_month% >= bunkering.%min_required_in_1_month% -
				         rule_exceptions.%overshoot_int%(round_down_month(wop.%start_UTC%));
  startdate  = round_down_month(wop.%start_UTC%);
  severity = first(leg(wop), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = %ind_min_freedays_in_1_month_ALL_failobject%;
  failtext(Int value, Int limit) = 
    rules.%failtext_int%(concat("Coll: F-days in ", 
                                format_time(wop.%start_month_start%, "%b")),
                         value, limit);
  remark "Coll: Min freedays in 1 month.",
  planner "Checks that VG crew are scheduled at least the "
          "minimum number of freedays required in a calendar month.";
end

/* Assuming that duty resolution is enough.*/
%ind_min_freedays_in_1_month_ALL_failobject% =
 let month = wop.%start_month_start%,
      nr_qual= freedays.%nr_qualifying_in_1_month%,
      overshoot = default(rule_exceptions.%overshoot_int%(wop.%start_UTC%),0),
      min_req = freedays.%min_required_in_1_month% - overshoot;
      
  default(last(duty(wop),
       if (sum(duty(chain),trip.%days_in_period%(duty.%start_day%,
                                                 duty.%end_day% + 24:00) -
                     (if(duty.%start_day% = prev(duty(chain),duty.%end_day%)) then 1 else 0))
              from (current) forwards while (duty.%start_month_start% = month) where
              (%_duty_can_make_freeday%) >=
                  min_req - 
                  nr_qual) then
    duty.%failobject_start% 
  else
    prev(duty(chain),duty.%failobject_start%) where
       (sum(duty(chain),duty.%days_in_period%(duty.%start_day%,
                                              duty.%end_day% + 24:00) -
                  (if(duty.%start_day% = prev(duty(chain),duty.%end_day%)) then 1 else 0))
              from (current) forwards while (duty.%start_month_start% = month) where
              (%_duty_can_make_freeday%) >=
                  min_req - 
                  nr_qual)) where
  (duty.%start_month_start% = month),
  wop.%failobject_start%); 

%_duty_can_make_freeday% = 
  not duty.%is_bought% and 
  not duty.%is_blank_day% and
  (not (duty.%start_day% = prev(duty(chain),duty.%end_day%)) or
   duty.%start_day% = prev(duty(chain),duty.%end_day%) and
   (duty.%end_day% = next(duty(chain),duty.%start_day%) or
    not (duty.%end_day% + 24:00 = next(duty(chain),duty.%start_day%)))) and
  (duty.%is_on_duty% and not duty.%is_compensation_day%);
  
/* Defined in child modules due to different validity */
export %r_valid_freedays_in_1_month% = Bool;


/*******
**  Rule:
**    Minimum number of freedays and F36 days in month
**  
**  F36 optimization:
**  Freedays are included in this rule since empty space in roster before
**  Post-opt assignment is reserved for either freedays or F36
*/

export rule ind_min_freedays_and_f36_in_1_month_ALL =
  valid roster.%check_rules% and
        crew.%is_cabin% and
        freedays.%required_f36_days_in_month% > 0 and
        not crew.%is_leased_wop_start% and
        not (crew.%is_skd% and crew.%is_temporary%) and
        wop.%start_month_start% = %pp_start% and
        wop.%start_hb% <= %pp_end% and
        wop.%is_last_on_duty_in_month% and
        %r_valid_freedays_in_1_month%; 
  %total_f36_days_in_month% >=  
  freedays.%required_f36_days_in_month% - rule_exceptions.%overshoot_int%(wop.%start_month_start%);
  startdate  = wop.%start_month_start%;
  severity = first(leg(wop), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = %ind_min_freedays_in_1_month_ALL_failobject%;
  failtext(Int value, Int limit) = 
    rules.%failtext_int%(concat("Coll: F36-days in ",
                                format_time(wop.%start_month_start%, "%b")),
                         value - freedays.%min_required_in_1_month%, limit - freedays.%min_required_in_1_month%);
  remark "Coll: Min F36 days in 1 month.",
  planner "Checks that VG crew are scheduled at least the "
          "minimum number of F36 days required in a calendar month.";
end

export %crew_may_have_f36% = True;

export %total_f36_days_in_month% = 
  freedays.%f36_days_in_month% +
  %potential_f36_days_in_month%;

%potential_f36_days_in_month% = if crew.%in_variable_group_pp_end% then
                                     nmin((freedays.%nr_qualifying_in_1_month%
                                          - freedays.%min_required_in_1_month%),
                                         %open_days_in_1_month%)
                                   else
                                     %open_days_in_1_month%;

export %open_days_in_1_month% =
    let m_start = wop.%start_month_start%, 
        m_end = wop.%start_month_end%;
  default(
  sum(duty(roster),overlap(m_start,m_end,duty.%end_day% + 24:00 ,next(duty(roster), duty.%start_day%))/24:00)
  from (current) backwards
  while (duty.%end_utc% + freedays.%min_required_freedays_after_duty_total% * 24:00 > m_start),
  0)
  +
  default(  
  sum(duty(roster),overlap(m_start,m_end,duty.%end_day% + 24:00 ,next(duty(roster), duty.%start_day%))/24:00)
  from (current) forwards
  while (duty.%end_utc% < m_end),
  0);

/* Chain level function used by colgen resource constraint*/
export %open_days_in_1_month_function%(abstime m_start, abstime m_end) =
  sum(duty(roster),overlap(m_start,m_end,duty.%end_day% + 24:00 ,default(next(duty(roster), duty.%start_day%), m_end))/24:00);

%req_freedays_after_duty_in_1_month% =
let m_start = wop.%start_month_start%,
    m_end  = wop.%start_month_end%;
  sum(duty(roster),overlap(m_start,m_end,duty.%end_day% + 24:00 ,duty.%end_day% + 24:00 + freedays.%min_required_freedays_after_duty_total% * 24:00)/24:00)
  from (current) backwards 
  while (duty.%end_utc% + freedays.%min_required_freedays_after_duty_total% * 24:00 > m_start)
  where(%_duty_is_last_in_wop%);

%_duty_is_last_in_wop% = duty.%end_utc% = wop.%end_utc%;

/* Rule:
**   Superfreedays in Calender year
**
** Description:
**   This rule checks that the number of assigned super freedays 
**   in calender year are no more than max allowed
**
**   This rule shall be activated when SKCMS-649 is implemented
*/

export rule ind_max_fs_days_in_calendar_year =
  valid roster.%check_rules%
   and duty.%is_ac_employer_sk%
   and crew.%is_pilot%
   and crew.%in_variable_group_trip_start% 
   and duty.%in_pp_extended% 
   and %is_last_fs_day_in_month% 
   and not crew.%is_leased_duty_start%
   and not crew.%has_agmt_group_skn_fd%;
        
  %number_of_fs_in_calendar_year% <=  %max_number_fs_days_in_calendar_year% + 
    rule_exceptions.%overshoot_int%(duty.%start_UTC%);
  startdate  = duty.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = %ind_max_fs_days_in_calender_year_failobject%;
  failtext(Int value, Int limit) =
    rules.%failtext_int%("Coll: Max superfreedays in calender year", value, limit);
  remark "Coll: Max number of superfreedays in calender year",
  planner "Check that the number of assigned super freedays in "
          " calender year ";
end

%ind_max_fs_days_in_calender_year_failobject% =
  let overshoot = default(rule_exceptions.%overshoot_int%(duty.%start_UTC%),0),
      start     = round_down_year(duty.%start_UTC%);
  default(prev(duty(chain), next(duty(chain),duty.%failobject_start%) where
               (duty.%is_fs%)) where
    (duty.%is_fs% and
    freedays.%super_freedays_in_period_from_account%(start - 0:01,
                                                     duty.%end_day%) <= 
    %max_number_fs_days_in_calendar_year% + overshoot),
    duty.%failobject_start%);

%number_of_fs_in_calendar_year% =
    freedays.%super_freedays_in_period_from_account%(round_down_year(duty.%start_UTC%),round_up_year(duty.%start_utc%-0:01));
  
%max_number_fs_days_in_calendar_year% = 12;



/*
** Rule:
**    Minimum free weekends in period (calendar month)
**
** Description:
**    The rule checks that there is at least 1 free weekend in period (calendar month).
**    The rule is valid for both LH and SH.
**
** Agreement:
**    FC 1:12.3, 1:18.2.5d, SKI K06 ???
**    CAU J.1.2c, J.2.1.5
**    NKF 8
**    SCCA H.1.4a, H.2.5
**    FD K22 �5 stk 7.1 (SKCMS-3067)
**
**  NOTE:
**  Resource constraint for CG for this rule is defined in cg_model
**
*/
export rule ind_min_free_weekend_in_period_ALL =
  valid %ind_min_free_weekend_in_period_ALL_valid%
    and rule_exceptions.%rule_on%(trip.%start_month_start%);

    freedays.%has_free_weekend_in_period_by_date%(trip.%start_month_start%);
  startdate  = trip.%start_month_start%;
  severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = trip.%failobject_start%;
  failtext %min_free_weekends_in_period_failtext%;
  remark "Coll: Min 1 free weekend in calendar month",
  planner "Check that at least 1 free weekend is scheduled in the calendar month.";
end

%ind_min_free_weekend_in_period_ALL_valid% =
    roster.%check_rules% and
    crew.%in_variable_group_wop_start% and
    freedays.%trip_is_last_not_free_we_in_month% and
    %r_valid_min_free_weekends% and
    not (%flight_crew% and
    training.%month_is_in_school_period_min_7x24% and
    training.%wop_is_in_school_period_min_7x24%) and
    not crew.%is_leased_wop_start% and
    not (crew.%is_temporary% and
        (crew.%has_agmt_group_skn_cc_at_date%(%pp_start%) or
        (crew.%has_agmt_group_skd% or not (format_time(trip.%start_month_start%, "%b") in summer_months)))) and
    not (crew.%has_agmt_group_skk_cc% or crew.%has_agmt_group_skj_cc%); /* Because others crew like asian CC are not covered by this rule */

%agreement_valid_ind_min_free_weekend_in_period_qa_k15%(Abstime pp_start) =
  %agreement_valid%("min_free_we_monthly_qa_k15", pp_start);

%ind_min_free_weekend_in_period_ALL_failobject% =
  last(leg(wop),
       if %leg_in_weekend% and prev(leg(chain), not %leg_in_weekend%) then
          leg.%failobject_departure%
       else
          prev(leg(chain), leg.%failobject_departure%)
          where(%leg_in_weekend% and prev(leg(chain), not %leg_in_weekend%)));
        
/* Check for borderline errors */
%leg_in_weekend% =
    any(times(freedays.%free_we_interval_max_number_of_types%),
        (time_of_week(leg.%start_hb%)>freedays.%free_we_start_tow%(%times_index_0%) and
        time_of_week(leg.%start_hb%)<=freedays.%free_we_start_tow%(%times_index_0%) + freedays.%free_we_length%) or
        (time_of_week(leg.%co_end_hb%)<=freedays.%free_we_start_tow%(%times_index_0%) + freedays.%free_we_length% and
        time_of_week(leg.%co_end_hb%)>freedays.%free_we_start_tow%(%times_index_0%))
    );

%r_valid_min_free_weekends% =
  /* This must be added since there is a bug for planning periods spanning
  ** over 2 months, e.g. 15aug-15sep (which could be used in CCT).
  ** Otherwise, the rule must be checked for all on duty wops. 
  */

  trip.%start_month_start% = round_down_month(%pp_start%);

%min_free_weekends_in_period_failtext% =
  concat("Coll: No free weekend in ",
           format_time(trip.%start_month_start%, "%b"));

/********************
*** Super Freedays **
********************/

%agreement_valid_4exng_fs_day_logic% = 
  %agreement_valid%("4exng_fs_day_logic", trip.%start_utc%);

/* Rule:
**   Superfreeday placed correctly
**
** Description:
**   This rule checks that superfreedays are placed correctly in 
**   regards to other superfreedays. 
**   
*/
export rule (off) ind_max_consecutive_fs_days = 
  valid roster.%check_rules% and
    not crew.%is_leased_duty_start% and
    duty.%is_fs% and
    %agreement_valid_4exng_fs_day_logic% and
    crew.%has_agmt_group_sk% and 
    crew.%in_variable_group_trip_start% and
    duty.%in_pp_extended% and
    rule_exceptions.%rule_on%(duty.%start_utc%);

  %consecutive_fs_duties_total% <= %max_number_super_freedays_in_month%;

  startdate  = duty.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = duty.%failobject_start%;
  failtext concat("Coll: FS block exceeds the max allowed value of ", format_int(%max_number_super_freedays_in_month%, "%d"));
  remark "Coll: FS days in succession",
  planner "Verify that the number of FS days in a row does not exceed the maximum allowed value";
end

%consecutive_fs_duties_total% =
  %consecutive_fs_duties_backward% +
  %consecutive_fs_duties_forward%;

%consecutive_fs_duties_backward% =
  sum(duty(wop), duty.%days%)
  from (prev) backwards
  while (duty.%is_fs%);

%consecutive_fs_duties_forward% =
  sum(duty(wop), duty.%days%)
  from (current) forwards
  while (duty.%is_fs%);

/* Rule:
**   Superfreeday placed correctly - SKD CC.
**
** Description:
**   Based on the Inshape agreement SKD CC have the right too 3 FS/month, they cannot however not
**   not be placed in a row. See SKCMS-1894.
**
*/

export rule ind_incorrect_separated_fs_days =
    valid roster.%check_rules% and
    not crew.%is_leased_duty_start% and
    duty.%is_fs% and
    %agreement_valid_4exng_fs_day_logic% and
    %cabin_crew% and crew.%is_SKD% and
    crew.%in_variable_group_trip_start% and
    duty.%in_pp_extended% and
    rule_exceptions.%rule_on%(duty.%start_utc%);

    %fs_blocks_in_month% <= %allowed_fs_blocks_per_month%;

    startdate  = duty.%start_UTC%;
    severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
    failobject = duty.%failobject_start%;
    failtext "Coll: FS days distribution is incorrect";
    remark "Coll: FS days distribution is incorrect",
    planner "Verify that the distribution of FS days follows the existing agreement";
end

%allowed_fs_blocks_per_month% =
    2;

%fs_blocks_in_month% =
  %fs_blocks_backward% +
  %fs_blocks_forward%;

%fs_blocks_backward% =
  let cur_month = round_down_month(duty.%start_hb%);
  count(duty(chain))
  from (prev) backwards
  while(round_down_month(duty.%start_hb%) = cur_month)
  where (duty.%is_fs% and not duty.%previous_is_FS%);

%fs_blocks_forward% =
  let cur_month = round_down_month(duty.%start_hb%);
  count(duty(chain))
  from (current) forwards
  while(round_down_month(duty.%start_hb%) = cur_month)
  where (duty.%is_fs% and not duty.%previous_is_FS%);

export rule ind_max_fs_fw_days_in_a_row =
  valid %_ind_max_fs_fw_days_in_a_row_valid%;

  %_fs_fw_in_a_row% <= %_max_fs_fw_days_in_a_row%
                                 + rule_exceptions.%overshoot_int%(duty.%start_UTC%);

  startdate  = duty.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = duty.%failobject_start%;
  failtext concat("Coll: FS/FW duties in a row exceeds the max limit ", format_int(%_max_fs_fw_days_in_a_row%, "%d"));
  remark "Coll: FS/FW days in a row",
  planner "Verify that the number of FS/FW days in a row does not exceed the maximum limit";
end

%_ind_max_fs_fw_days_in_a_row_valid% =
   roster.%check_rules% and
   %_is_last_fs_in_block% and
   crew.%in_variable_group_trip_start% and
   duty.%in_pp_extended%;

%_fs_block_start% =
  min(duty(wop), duty.%start_hb%)
  from (current) backwards
  while (duty.%is_fs%);

%_fs_block_start_tow% =
  time_of_week(%_fs_block_start%)/24:00 +1;

%_fs_days_covers_we% =
     (%_fs_block_start_tow% <= 6 and (%_fs_block_start_tow% + %consecutive_fs_duties_total%) >= 8)
     or %consecutive_fs_duties_total% >= 8;

%_is_last_fs_in_block% =
 let ed = duty.%end_hb%,
     is_fs = duty.%is_fs%;
     is_fs and not any(duty(wop), duty.%is_fs% and duty.%start_hb% = ed);

%_max_fs_fw_days_in_a_row% =
  if (crew.%has_agmt_group_snk_cc_at_date%(trip.%start_hb%) and %_fs_days_covers_we%) or /*SKCMS-1801: Added at_date to fix bug where incorrect agmt group could be a choosen */
  (crew.%has_agmt_group_nkf_cc_at_date%(trip.%start_hb%) and %_fs_days_covers_we%) or 
 ((crew.%has_agmt_group_sk_sh_fd%) and (%_is_fs_before_fw% or %_is_fs_after_fw%) )
  then 3
  else 2;

%_is_fs_before_fw% =
 let ed = duty.%end_hb%,
     is_fs = duty.%is_fs%;
     is_fs and any(duty(roster), duty.%is_fw% and duty.%start_hb% = ed);

%_is_fs_after_fw% =
 let st = duty.%start_hb%,
     is_fs = duty.%is_fs%;
     is_fs and any(duty(roster), duty.%is_fw% and duty.%end_hb% = st);

%_fs_fw_in_a_row% =
  %_fs_fw_in_a_row_backward% +
  %_fs_fw_in_a_row_forward%;

%_fs_fw_in_a_row_backward% =
  sum(duty(wop), duty.%days%)
  from (prev) backwards
  while (duty.%is_fs% or duty.%is_fw%);

%_fs_fw_in_a_row_forward% =
  sum(duty(wop), duty.%days%)
  from (current) forwards
  while (duty.%is_fs% or duty.%is_fw%);


/* Rule:
**   Superfreeday placed correctly
**
** Description:
**   This rule checks that superfreedays are placed correctly in 
**   regards to VA and LA. 
**   
*/

export rule ind_fs_day_scheduled_correct_all =
  valid roster.%check_rules% and
      not crew.%is_leased_duty_start% and
        (duty.%is_fs% or duty.%is_FS1%) and
        crew.%in_variable_group_trip_start% and
        (%flight_crew% and
         ((parameters.%k11_fc_sp2_2_valid%(duty.%start_hb%) and
           parameters.%is_request_bidding% and crew.%is_SKI%) or
          (parameters.%k11_fc_sp2_2_valid%(duty.%start_hb%) and
           not crew.%is_SKI%) or
         (not parameters.%k11_fc_sp2_2_valid%(duty.%start_hb%) and
           crew.%is_SKD%))
         or
         crew.%has_agmt_group_sk_cc%) and
        duty.%in_pp_extended% and
        rule_exceptions.%rule_on%(duty.%start_utc%) and
        (true or %param_allow_fs_immediately_after_summer_va% and
        %param_allow_fs_immediately_before_summer_va%);
  %fs_day_placed_correct%;
  startdate  = duty.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = duty.%failobject_start%;
  failtext "FS day not scheduled correct";
  remark "Coll: FS day scheduled correct",
  planner "Check that FS day(s) is scheduled correct"
          " For all FC:s VA or LA must be at least 7 days long for rule to apply"
          " For FC K11, FS day cannot be placed closer than 6 days (summer VA)"
          " or 5 days (winter) before VA/LA, or 3 days after VA/LA. If summer"
          " and F14 assigned before/after VA, FS cannot be placed closer than"
          " number of F14 + 3 days, before or after VA."
          " For FC SKD FS day cannot be placed closer than 5 days before VA/LA"
          " or 3 days after VA/LA."
          " For all CC: VA or LA must be at least 5 days long for rule to apply"
          " For CC SKD FS cannot be placed closer than 5 days before VA or"
          " 3 days after VA"
          " For CC SKS FS cannot be placed closer than 5 days before/after VA/LA"
          " or block of more than 3 F7S days";
end

/*
** Ensures an FS or FS1 day is placed correctly in relation to upcoming 
** vacation or other activities (defined in %valid_activity%)
**
** Example: (E stands for empty days) 
**          | FS | E 3 days | VA 7 days | - Not valid since not enough open days prior VA longer than limit
**          | FS | E 6 days | VA 7 days | - Valid since more than enough open days
**          | FS | E 2 days | VA 3 days | - Valid since VA not long enough to trigger rule (differs between FD & CC)
**
** Exception to this logic implemented in SKCMS-1947 in %fs_days_before_valid_activity_check%
*/
%next_activity_placed_correct%(Abstime day_after_fs_end_day) =
      default(next(duty(chain), %fs_days_before_valid_activity_check%(%days_since%(duty.%start_day%,day_after_fs_end_day)))
            where (%valid_activity% and %check_FS_friends% and (%flight_crew% and %check_next_activity_length%(%max_length_not_triggering_rule_fd%)
            or %cabin_crew% and %check_next_activity_length%(%max_length_not_triggering_rule_cc%)))
            while (%days_since%(duty.%start_day%, day_after_fs_end_day) < 10),
          true);
          
%check_next_activity_length%(Int limit) =
  let start_day = duty.%start_day%,
      end_day = start_day + (limit + 1) * 24:00;
  %count_days_in_period_with_activity%(start_day, end_day, task.%fs_disqual_activities%) > limit;

%fs_days_before_valid_activity_check%(Int days_until_valid_activity) =
      let is_in_f14_exception_group = (crew.%has_agmt_group_sks_fd% or crew.%has_agmt_group_skis_fd%);
      if (is_in_f14_exception_group and %is_valid_vacation_code% and %next_duty_is_f14% and days_until_valid_activity < %days_allowed_before_va%) then
        false
      else if (freedays.%vacation_length% >= 19 and freedays.%wop_is_vacation_starting_in_summer_period% and days_until_valid_activity <= %days_allowed_before_va%) then
        %_crew_is_skn%
      else
        days_until_valid_activity >= %days_before% or
        (%is_valid_vacation_code% and (days_until_valid_activity < %days_allowed_before_va%));

%is_valid_vacation_code% = duty.%code% in task.fs_valid_vacation_codes;

%next_duty_is_f14% =
  default(next(duty(chain), duty.%code% = "F14"), false);

%days_allowed_before_va% = 2;

/*
** Similar to %next_activity_placed_correct% but checks that previous VA or other 
** activity at valid length is placed correctly in relation to FS/FS1
*/
%prev_activity_placed_correct%(Abstime duty_start_day) =
      default(prev(duty(chain), %days_since%(duty_start_day,duty.%end_day% + 24:00) >= %days_after%)
            where (%valid_activity% and (%flight_crew% and %check_prev_activity_length%(%max_length_not_triggering_rule_fd%)
            or %cabin_crew% and %check_prev_activity_length%(%max_length_not_triggering_rule_cc%)))
            while (%days_since%(duty_start_day,duty.%end_day% + 24:00) <  10),
          true);

%check_prev_activity_length%(Int limit) =
  let end_day = duty.%end_day% + 24:00,
      start_day = end_day - (limit + 1) * 24:00;
  %count_days_in_period_with_activity%(start_day, end_day, task.%fs_disqual_activities%) > limit;

%max_length_not_triggering_rule_fd% = 6; /* Max amount of consecutive "valid activity" days for the rule to pass */
%max_length_not_triggering_rule_cc% = 4;


%fs_day_placed_correct% = 
  let duty_start_day = duty.%start_day%,
      day_after_duty_end_day = duty.%end_day% + 24:00;
  (%next_activity_placed_correct%(day_after_duty_end_day) or %_allow_fs_before_summer_va%)
  and (%_allow_fs1_after_7_days_va% or %_allow_fs_after_7_days_va% or
        (%prev_activity_placed_correct%(duty_start_day) or %_allow_fs_after_summer_va% ))
  and %assert_legal_fs_fw_combination_forwards_backwards%(duty.%start_hb%, duty.%end_hb%)
  and not %snk_fs_day_before_7_days_vac_excl_summer_va%;

%_crew_is_skn% =
  (crew.%has_agmt_group_nkf_cc_at_date%(duty.%start_hb%) or
   crew.%has_agmt_group_snk_cc_at_date%(duty.%start_hb%));

%_allow_fs_before_summer_va% =
  %_crew_is_skn%
  and %param_allow_fs_immediately_before_summer_va%
  and %fs_immediately_before_summer_va%;

%_allow_fs_after_summer_va% =
  %_crew_is_skn%
  and %param_allow_fs_immediately_after_summer_va%
  and %fs_immediately_after_summer_va%;

%_allow_fs_after_7_days_va%=
  %_crew_is_skn%
  and %fs_immediately_after_7_days_va%;

%_allow_fs1_after_7_days_va%=
  %_crew_is_skn%
  and %fs1_immediately_after_7_days_va%;

%param_allow_fs_immediately_after_summer_va% =
    parameter True
    remark "Allow FS immediately after summer vacation (SKN CC)";

%param_allow_fs_immediately_before_summer_va% =
    parameter True
    remark "Allow FS immediately before summer vacation (SKN CC)";

%snk_fs_day_before_7_days_vac_excl_summer_va% =
   crew.%has_agmt_group_snk_cc_at_date%(leg.%start_hb%)
   and not %fs_immediately_before_summer_va%
   and %fs_immediately_before_7_days_va%;

/*
* This function assert cases:
*                               FW/FS/3days_no_FW          => True
*                               3days_no_FW/FS/FW          => True
*                               3days_no_FW/FS/3days_no_FW => True
*/
%assert_legal_fs_fw_combination_forwards_backwards%(abstime start_hb, abstime end_hb) =
    if %has_days_in_period_with_activity%(start_hb - 24:00, start_hb, "FW") then
        not %has_days_in_period_with_activity%(end_hb, end_hb + 72:00, "FW")
    else if %has_days_in_period_with_activity%(end_hb, end_hb + 24:00, "FW") then
        not %has_days_in_period_with_activity%(start_hb - 72:00, start_hb, "FW")
    else
        %count_days_in_period_with_activity%(start_hb - 72:00, end_hb + 72:00, "FW") = 0;

%check_FS_friends% = 
    if system_db_parameters.%IB6_valid%(duty.%start_UTC%) 
       then any(leg(duty), not task.%is_fs_friends%(task.%code%))
    else true;

/* Redefined in rules_indust_ccr_cc for CC */
%fs_immediately_before_summer_va% = false;
%fs_immediately_after_summer_va% = false;
%fs_immediately_after_7_days_va% = false;
%fs_immediately_before_7_days_va% = false;
%fs1_immediately_after_7_days_va% = false;

%days_before% = void_int;
%days_after% = void_int;
%valid_activity% = void_bool;
%military% = void_bool;
%course% = void_bool;
%max_consecutive_fs_days% = void_int;

/* Rule:
**   Minimum days between FS super freedays
**
** Description:
**   This rule checks that there are are at least 3 days between isolated, or   
**   blocks of, FS-days.
**
**   E.g. FS/x/x/x/FS/FS/FS/x/x/x/FS/FS/x/x/x/FS/x/x/x/FS/x/.....
*/
export rule ind_min_days_between_fs =
  valid %_valid_ind_min_days_between_fs% and
        rule_exceptions.%rule_on%(trip.%start_utc%);
        
  %days_to_prev_fs% >= %min_days_between_fs%;
  
  startdate  = trip.%start_UTC%;
  severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = trip.%failobject_start%;
  failtext concat("Coll: Min ", base_utils.%int2str%(%min_days_between_fs%), " days btw FS days");
  remark "Coll: Minimum 3 days between FS days",
  planner "Check that there are at least 3 days between isolated, or blocks of FS days.";
end

%_valid_ind_min_days_between_fs% =
        roster.%check_rules% and
        not crew.%is_leased_trip_start% and
        (trip.%is_fs% or trip.%is_fs1%) and
        not (prev(trip(chain),trip.%is_fs% or trip.%is_fs1%) and
             trip.%start_day% = prev(trip(chain),trip.%end_day%) + 24:00) and
        (%flight_crew% or
        %cabin_crew% and (crew.%is_SKD% or crew.%is_SKS% or crew.%is_SKN%)) and
        crew.%in_variable_group_trip_start% and
        trip.%in_pp_extended%;

%days_to_prev_fs% =
  let trip_start_day = trip.%start_day%;
  prev(trip(chain), %days_since%(trip_start_day, trip.%end_day% + 24:00))
  where (trip.%is_fs% or trip.%is_fs1%)
  while (%days_since%(trip_start_day, trip.%end_day% + 24:00) < %min_days_between_fs%);

%min_days_between_fs% = 3;


export rule ind_max_fs_days_month_nkf_snk_cc =
  valid	%ind_max_fs_days_month_nkf_snk_cc_valid%;

  %no_of_fs_in_month_nkf_snk_cc%<=
  %max_number_fs_in_month_nkf_snk_cc% +
    rule_exceptions.%overshoot_int%(duty.%start_UTC%);
  startdate  = leg.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = %ind_max_fs_days_month_snk_nkf_failobject%;
  failtext(Int value, Int limit) =
    rules.%failtext_int%(%max_number_fs_in_month_failtext%, value, limit);
  remark "Coll: Max number of superfreedays in month (snk/nkf)",
  planner "Check that the number of assigned super freedays in month"
          " is no more than allowed. If there is an FS weekend, covering"
          " both Saturday and Sunday, there might be 3 FS days, otherwise 2.";
end

%ind_max_fs_days_month_nkf_snk_cc_valid% =
        roster.%check_rules%
	and crew.%has_agmt_group_skn_cc_at_date%(leg.%start_hb%)
	and crew.%in_variable_group_trip_start%
	and (leg.%is_FS% or leg.%is_FS1%)
	and leg.%start_hb% >= round_down_month(%pp_start%)
	and leg.%start_hb% < round_up_month(%pp_end%)
	and not crew.%is_leased_duty_start%;


%max_number_fs_in_month_failtext% =  if freedays.%no_of_fs_weekends_in_month% < 1
                     then "Max superfreedays in month when no FS weekend "
                     else "Max superfreedays in month " ;

%additional_fs_day_if_last_day_in_month_is_saturday% =
  if base_calendar.%wd_from_abs%(round_up_month(leg.%start_hb%) - 0:01)=base_calendar.%saturday% then
    1
  else
    0;
%number_of_fs_days_in_month_snk_nkf_cc_baseline% = if freedays.%no_of_fs_weekends_in_month% < 1 then 2 else 3;
%max_number_fs_in_month_nkf_snk_cc% =
  /*%additional_fs_day_if_last_day_in_month_is_saturday% +*/
  %number_of_fs_days_in_month_snk_nkf_cc_baseline%;

%ind_max_fs_days_month_snk_nkf_failobject% =
  let overshoot = default(rule_exceptions.%overshoot_int%(duty.%start_UTC%),0),
      month     = round_down_month(leg.%start_hb%);
  default(prev(leg(chain), next(leg(chain),leg.%failobject_departure%) where
               (leg.%is_fs%)) where
    (leg.%is_fs% and round_down_month(leg.%start_hb%) = month and
    freedays.%super_freedays_in_period_from_account%(round_down_month(leg.%start_hb%) - 00:01,
                                                     round_up(leg.%end_hb%,24:00)) 
    <= %max_number_fs_in_month_nkf_snk_cc%  + overshoot),
    leg.%failobject_departure%);

%no_of_fs_in_month_nkf_snk_cc% =
  let start_time=
       if base_calendar.%wd_from_abs%(round_down_month(leg.%start_hb%))=
          base_calendar.%sunday% then
          round_down_month(leg.%start_hb%) - 48:00
       else
         round_down_month(leg.%start_hb%) - 0:01,
     end_time =
       if base_calendar.%wd_from_abs%(round_up_month(leg.%start_hb%+0:01)) =
          base_calendar.%sunday% then
          round_up_month(leg.%start_hb%+0:01) - 48:00
       else
          round_up_month(leg.%start_hb%+0:01) - 0:01;
  
  freedays.%super_freedays_in_period_from_account%(start_time, end_time);

/* Rule:
**   Superfreedays in month
**
** Description:
**   This rule checks that the number of assigned super freedays in month
**   are not more than allowed
** 
** Agreement:
**
*'  CAU J.3.c
**  FC K11 6.1.16
*/
export rule ind_max_fs_days_month =
  valid roster.%check_rules% and
	not crew.%has_agmt_group_skn_cc_at_date%(duty.%start_hb%) and
        crew.%in_variable_group_trip_start% and
        (duty.%start_hb% >= round_down_month(%pp_start%) and 
         duty.%start_hb% < round_up_month(%pp_end%)) and
        %is_last_fs_day_in_month% and
        not crew.%is_leased_duty_start%;
        
  freedays.%super_freedays_in_period_from_account%(duty.%start_month_start% - 00:01,
                                                   duty.%start_month_end% - 00:01) <= 
  %max_number_super_freedays_in_month% + 
    rule_exceptions.%overshoot_int%(duty.%start_UTC%);
  startdate  = duty.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = %ind_max_fs_days_month_failobject%;
  failtext(Int value, Int limit) =
    rules.%failtext_int%("Coll: Max superfreedays in month", value, limit);
  remark "Coll: Max number of superfreedays in month",
  planner "Check that the number of assigned super freedays in month"
          " is no more than allowed."
          " Valid for CPH cabin crew, and K11 FC SH, in variable group";
end

%ind_max_fs_days_month_failobject% =
  let overshoot = default(rule_exceptions.%overshoot_int%(duty.%start_UTC%),0),
      month     = duty.%start_month_start%;
  default(prev(duty(chain), next(duty(chain),duty.%failobject_start%) where
               (duty.%is_fs%)) where
    (duty.%is_fs% and duty.%start_month_start% = month and
    freedays.%super_freedays_in_period_from_account%(duty.%start_month_start% - 00:01,
                                                     duty.%end_day%) 
    <= %max_number_super_freedays_in_month% + overshoot),
    duty.%failobject_start%);

%is_last_fs_day_in_month% =
  let month_end = round_up_month(duty.%start_hb% + 00:01);
    
  duty.%is_fs% and 
  default(next(duty(chain), duty.%start_hb% >= month_end)
          where(duty.%is_fs%),
          True);

/* Can be used when SKCMS-646 shall be used, i.e. when SKCMS-649 is introduced
   Do not forget to delete the IB6_validity row
*/ 
  
export %max_number_super_freedays_in_month% =
  if not system_db_parameters.%IB6_valid%(duty.%start_UTC%) 
  then
    if %flight_crew% and
      crew.%in_variable_group%(duty.%start_month_start%) and
      crew.%is_short_haul%(duty.%start_month_start%) and
      (crew.%is_SKD% or crew.%is_SKN% or crew.%is_SKS%)
    then
      3 
    else
      2
  else
    /* IB6 valid */ 
    if %flight_crew% and
       crew.%in_variable_group%(duty.%start_month_start%) and
       crew.%is_short_haul%(duty.%start_month_start%) and
       (crew.%is_SKD% or crew.%is_SKN% or crew.%is_SKS%)
    then
        if crew.%has_agmt_group_skn_fd% then
            %_max_FS_SKN_FD_in_month%
        else
                1 /* SKS-FD-AG, SKD-FD-AG */
    else
     if crew.%has_agmt_group_skd_cc% then
         3 /* SKD-CC */
     else
      2; /* CC and SKI-FD-AG */

%_max_FS_SKN_FD_in_month% =
  if %consecutive_fs_duties_total% = 2
  then 2
  else 1;

/* max number of requested weekend free as FW activity code by FD crew is one weekend (saturday + sunday) */
%max_number_weekend_free_requested_ib6_in_month% =
  if %flight_crew% and
    crew.%in_variable_group%(duty.%start_month_start%) and
    duty.%is_ac_employer_sk%
  then
    1
  else
    0;

/* Rule:
**   Superfreedays in weekend must cover both Saturday and Sunday.
**
** Description:
**   This rule checks that superfreedays in a weekend covers both 
**   Saturday and Sunday.
**   Rule is only valid for SKS cabin crew.
**   
*/

export rule (on) ind_fs_days_in_weekend_covers_both_saturday_and_sunday =
  valid roster.%check_rules% and
	crew.%has_agmt_group_skn_cc_at_date%(duty.%start_hb%) and
        crew.%in_variable_group_trip_start% and
        duty.%in_pp_extended% and
        not crew.%is_leased_duty_start% and
        rule_exceptions.%rule_on%(duty.%start_utc%);
        
        default(%fs_days_covers_both_saturday_and_sunday%,true);
        
  startdate = duty.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%, %duty_lh_region%));
  failobject = duty.%failobject_start%;
  failtext  concat("FS  days in weekend must cover both Saturday and Sunday ",base_utils.%abstime2str7%(duty.%end_hb%));
  remark "Coll: FS days in weekend must cover both Saturday and Sunday.",
  planner "Checks that superfreedays in a weekend covers both Saturday and Sunday";
end


%fs_days_covers_both_saturday_and_sunday% =
  let start_hb = duty.%start_hb%;
  if duty.%is_fs% then
    if time_of_week(duty.%end_hb% - 0:01) / 24:00 + 1 = 6 then
      default(next(duty(chain), time_of_week(duty.%start_hb%) / 24:00 + 1 = 7)
              where (duty.%is_fs%)
              while (duty.%start_hb% <= start_hb + 24:00)
      , false)
    else if time_of_week(duty.%start_hb%) / 24:00 + 1 = 7 then 
      default(prev(duty(chain), time_of_week(duty.%end_hb% - 0:01) / 24:00 + 1 = 6)
              where (duty.%is_fs%)
              while (duty.%start_hb% >= start_hb - 24:00)
      , false)
    else
      void_bool
  else
    void_bool;

/* Rule:
**   Only one weekend-off with FS per calendar month
**
** Description:
**   This rule checks that FS is not assigned on more than one weekend in a
**   calendar month.
**
**   FS weekends are calculated differently for crew in agreement groups
**   SKD/SKS_CC_AG since they are allowed to place single FS on Saturday/Sunday.
**   Other groups must place FS on both days.
**
**   NB! It is assumed that crew may only have 2 FS per month, either as
**   isolated days, or as two consecutive days.
*/



export rule ind_fs_on_weekend =
  valid roster.%check_rules% and
        not crew.%is_leased_trip_start% and
        trip.%is_fs_on_weekend% and
        not %fs_is_granted% and
        parameters.%k11_fc_sp2_2_valid%(trip.%start_hb%) and
        not crew.%is_SKI% and
        crew.%in_variable_group_trip_start% and
        trip.%in_pp_extended% and
        rule_exceptions.%rule_on%(trip.%start_hb%);

  %has_no_more_than_1_weekend_with_fs_in_month%;

  startdate  = trip.%start_hb%;
  severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = trip.%failobject_start%;
  failtext "FS allowed on only 1 weekend per calendar month";
  remark "Coll: FS allowed on only 1 weekend per calendar month",
  planner "Check that FS is not assigned on more than weekend in a calendar month."
          " FC SH K11, CC 4EX";
end


/*
* Table "crew_roster_request" is used to determine if a trip to be checked
* already has been granted. If a trip already has been granted "ind_fs_on_weekend"
* rule should not apply.
*/
%request_table_name% = "crew_roster_request";

table requests_period(Abstime start_date, Abstime end_date) =
  crew.%id%, trip.%code%, start_date, end_date ->
    export Int %num_granted_request%;
  external %request_table_name%;
  crew, type, st, et -> count(row_number);
end

/*
* Checks the "crew_roster_request" table if the trip to be
* checked already has been granted.
*/
%fs_is_granted% =
  if (%num_granted_request%(trip.%start_hb%, trip.%end_hb%) > 0) then
      true
  else
      false;

%has_no_more_than_1_weekend_with_fs_in_month% =
  if (crew.%has_agmt_group_skd_cc_at_date%(trip.%start_hb%) or
      crew.%has_agmt_group_sks_cc_at_date%(trip.%start_hb%)) then
    %weekends_with_fs_in_month_SKD_SKS% <= 1
  else
    %weekends_with_fs_in_month% <= 1;
/*
 * Counts the number of weekends (SAT, SUN) containing FS days in one month. 
 * For the special case of a weekend covering a month change (where Saturday
 * belongs to month 1 and Sunday belongs to month 2) the FS weekend will
 * be calculated as follows for SKD/SKS_CC_AG crew:
 * FS on Saturday only: FS will be included in month 1.
 * FS on Sunday only: FS will be included in month 2.
 * FS on Saturday and Sunday: FS will be included in month 2.
 */
%weekends_with_fs_in_month_SKD_SKS% =
  let month_start = round_down_month(trip.%start_hb%),
      month_end =  round_up_month(trip.%start_hb% + 0:01);
  count(trip(chain))
    from (current) backwards
    while (trip.%end_day% >= month_start)
    where (%is_fs_on_weekend_in_trip_month%(month_start, month_end) and
           not default(next(trip(chain),%is_fs_on_weekend_in_trip_month%(month_start, month_end + 24:00)) and
                       trip.%start_day% = next(trip(chain),trip.%start_day% - 24:00),
                       false) and
          not %exclude_weekend_on_month_break%(month_start));
/*
 * A weekend will be not be counted to this month FS weekends
 * if it covers a month break and doesn't end in this month.
 */
%exclude_weekend_on_month_break%(AbsTime month_start) =
  %trip_covers_month_break% and
  round_down_month(trip.%end_day%) <> month_start;

/*
 * A trip covers a month break if it starts and ends in two different months.
 */
%trip_covers_month_break% =
  let trip_start_month = round_down_month(trip.%start_day%),
      trip_end_month = round_down_month(trip.%end_day%);
  trip_start_month <> trip_end_month;

/*
 * Counts the number of weekends (SAT, SUN) containing FS days in one month.
 * For the special case of a weekend at month change where Saturday belongs to
 * month 1 and Sunday belongs to month 2 the entire FS-day-weekend will count
 * towards month 2. Special case for SKN CC where F0 weekends shall be counted
 * as FS weekends
 */
%weekends_with_fs_in_month% =
  let month_start = round_down_month(trip.%start_hb%),
      month_end =  round_up_month(trip.%start_hb% + 0:01);
  count(trip(chain))
    from (current) backwards
    while (trip.%end_day% >= month_start - 24:00)
    where ((%is_fs_on_weekend_in_trip_month%(month_start, month_end) or
    (crew.%is_SKN% and %is_f0_on_weekend_in_trip_month%(month_start, month_end))) and
           not default(next(trip(chain),%is_fs_on_weekend_in_trip_month%(month_start, month_end)) and
                       trip.%start_day% = next(trip(chain),trip.%start_day% - 24:00),
                       false) and
           not %saturday_trip_at_month_change%(month_start, month_end));

/*
 * If the weekend is divided between months FS days on Saturday should be counted
 * towards the month belonging to the Sunday. This variable is true when we have
 * a Saturday as the last day of the month and the month we are counting FS days
 * for is the same as the month of that last day.
 */
%saturday_trip_at_month_change%(AbsTime month_start, AbsTime month_end) =
  default(overlap(trip.%start_hb%,
          trip.%end_hb%,
          month_end -24:00,
          month_end) > 0:00, false) and
  %_touches_saturday%(((trip.%start_weekday%-1)*24:00),((trip.%start_weekday%-1)*24:00)+(trip.%days%*24:00));


%_touches_saturday%(Reltime start, Reltime stop) =
  overlap(start, stop, 120:00, 144:00) > 0:00;
  
%_touches_sunday%(Reltime start, Reltime stop) =
  overlap(start, stop, 144:00, 168:00) > 0:00;

%is_fs_on_weekend_in_trip_month%(Abstime month_start, Abstime month_end) = 
    trip.%is_fs% and
    overlap(trip.%start_hb%,
            trip.%end_hb%,
            %first_weekend_start_after_trip_start_and_month_start%(month_start),
            %first_weekend_end_after_trip_start_and_before_month_end%(month_start, month_end))
            > 0:00;

%is_f0_on_weekend_in_trip_month%(Abstime month_start, Abstime month_end) =
    trip.%is_f0% and
    overlap(trip.%start_hb%,
            trip.%end_hb%,
            %first_weekend_start_after_trip_start_and_month_start%(month_start),
            %first_weekend_end_after_trip_start_and_before_month_end%(month_start, month_end))
            > 0:00;

%first_weekend_start_after_trip_start_and_month_start%(Abstime month_start) =
    round_down_week(nmax(trip.%start_hb%, month_start)) + 5*24:00;

%first_weekend_end_after_trip_start_and_before_month_end%(Abstime month_start, Abstime month_end) =
    nmin(%first_weekend_start_after_trip_start_and_month_start%(month_start)
    + 48:00, month_end);

/* Rule:
**   Compensation day must be placed after production freedays
** 
** Description:
**   F31 may not be placed with production freedays all crew
**   F7S may not be placed with production freedays for SKD CC
**
** Agreement:
**   CAU ???
*/

rule ind_comp_day_after_production_freedays_all =
  valid roster.%check_rules% and
        trip.%in_pp% and
        not prev(trip(roster), trip.%is_cmp%) and
        (trip.%is_f31% or trip.%is_off_duty_cmp%) and
        rule_exceptions.%rule_on%(trip.%start_utc%);
        
  %comp_day_assigned_correct%;

  startdate  = trip.%start_UTC%;
  severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = trip.%failobject_start%;
  failtext concat("Coll: ", trip.%code%, " assigned incorrect");
  remark "Coll: No production before F7S, F31 of F89" ,
  planner "Check that F7S, F89 (SKD CC) and F31 (ALL) are placed correctly. "
          " If F7S, F31 and F89 are not first in production block, it means "
          " that they are not preceeded by production freedays";
end

%comp_day_assigned_correct% =
  is_first(trip(wop)) or 
  trip.%code% = prev(trip(wop), trip.%code%) or
  prev(trip(wop), trip.%is_f31%) or
  (trip.%is_off_duty_cmp% and default(next(trip(wop), trip.%is_off_duty_cmp%), true));

/***********************************************************************
** Rule:
**   F days around F7S in full block.
**   F7S in full block must be preceeded by 2 F and followed by 3 F days.
**
** Agreement:
**   NKF K10 ( Appendix C: 8.6 )
** 
************************************************************************/

rule ind_f7s_full_block_scheduled_with_freedays_ALL =
  valid roster.%check_rules% and
        parameters.%k11_skn_cc_valid%(%pp_start%) and
        not crew.%is_leased_duty_start% and
        %cabin_crew% and 
        crew.%is_SKN% and
        crew.%in_variable_group_trip_start% and
        %long_f7s_block% and
        duty.%in_pp_extended% and
        rule_exceptions.%rule_on%(duty.%start_utc%);

  %f7s_full_block_placed_correct%;
  startdate  = duty.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = duty.%failobject_start%;
  failtext "F7S in full block not scheduled correct";
  remark "Coll: F7S should be scheduled with freedays",
  planner "Check that F7S day(s) is scheduled correct"
          " For CC SKN: minimum 2 F days before F7S and 3F days after F7S"
          " when F7S is scheduled in full block";
end

%long_f7s_block% = false;

%enough_freedays_before_f7s% =
  default(%freedays_before_f7s% >= %min_freedays_before_f7s%, true);

%enough_freedays_after_f7s% =
  default(%freedays_after_f7s% >= %min_freedays_after_f7s%, true);

/*
** The agreement says 2 F-days required before an F7S block, but other off-duty 
** activities, with the exception of BL-days, are also acceptable
*/
%freedays_before_f7s% =
  %days_since%(
    duty.%start_hb%, 
    prev(duty(chain), round_up(duty.%end_hb%, 24:00))
      where(duty.%is_on_duty% and
            (not duty.%has_no_duty_time_contribution% or
             duty.%is_blank_day%)));

/*
** The agreement says 3 F-days required after an F7S block, but other off-duty 
** activities, with the exception of BL-days, are also acceptable
*/
%freedays_after_f7s% =
  %days_since%(
     next(duty(chain),duty.%start_hb%)
       where(duty.%is_on_duty% and
             (not duty.%has_no_duty_time_contribution% or
              duty.%is_blank_day%)), 
     round_up(duty.%end_hb%, 24:00));

%min_freedays_before_f7s% = 2;
%min_freedays_after_f7s% = 3;

%f7s_full_block_placed_correct% =
  %enough_freedays_before_f7s% and %enough_freedays_after_f7s%;

/* Rule:
**   F36 placed correctly
**
** Description:
**   This rule checks that F36 are placed correctly, i.e. as first off-duty 
**   after production, or as last off-duty before production.
*/

rule ind_f36_day_scheduled_correct_ALL =
  valid roster.%check_rules% and
        crew.%is_cabin% and
        not crew.%is_leased_duty_start% and
        duty.%is_f36% and
        duty.%in_pp_extended% and
        rule_exceptions.%rule_on%(duty.%start_utc%);
        
  %f36_day_placed_correct%;
  
  startdate  = duty.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = duty.%failobject_start%;
  failtext "F36 must be directly before/after other time-off";
  remark "Coll: F36 must be directly before/after other time-off",
planner "Check that F36 day(s) is directly before or after other time-off";
end

%f36_day_placed_correct% = 
let min_req_free_days = if crew.%in_variable_group_duty_end% then 
                          default(prev(duty(chain),freedays.%min_required_freedays_after_duty_total%)
                          where(duty.%is_on_duty% and not duty.%is_f36%), 2)
                        else 
                          3,
    start_f36 = duty.%start_day% - 24:00,
    end_f36 = duty.%end_day% + 24:00;
  not (default(prev(duty(chain), duty.%end_day% + min_req_free_days*24:00 > start_f36)
                 where (duty.%is_on_duty% and not duty.%is_f36%),
               false) and
       default(next(duty(chain), duty.%start_day% - min_req_free_days*24:00 < end_f36)
                 where (duty.%is_on_duty% and not duty.%is_f36%),
               false));


%previous_va_is_7_days_or_longer%(Abstime bid_day) =
  default(prev(wop(roster),wop.%is_vacation% and wop.%no_of_days% >= 7) where
          (wop.%end_hb% > (bid_day-72:00)), false); /* FS within 3 days after VA */
  
%next_wop_is_va_and_7_days_or_longer%(Abstime bid_day) =
  default(next(wop(roster),wop.%is_vacation% and wop.%no_of_days% >= 7) where
          ((bid_day >=round_down_month(wop.%start_hb%)) and (wop.%start_hb% = bid_day )), false); 

%_prev_VA_within_3_days%(Abstime bid_day) =
  default(prev(wop(roster), wop.%is_vacation%) where
          (wop.%end_hb% > (bid_day-72:00)), false); /* FS within 3 days after VA */

%_current_end_day% = base_calendar.%wd_from_abs%(leg.%end_hb%-0:01);

%ind_fs_weekend_can_be_granted_valid% =
    roster.%check_rules% and
    crew.%has_agmt_group_skn_cc_at_date%(leg.%start_hb%) and
    leg.%is_fs% and
    %_current_end_day%=base_calendar.%SUNDAY% and
    leg.%in_pp_extended% and
    (leg.%days%=2 or trip.%is_fs_on_weekend%) and
    not %fs_is_granted% and
    crew.%in_variable_group_trip_start% ;

%ind_fs_weekend_can_be_granted_reason_code% =
    if freedays.%no_of_fs_weekends_in_month% > 1 then
      1
    else if freedays.%any_free_weekend_in_month%(round_down(leg.%end_hb%, 24:00)) and not
            %previous_va_is_7_days_or_longer%(leg.%start_hb%) and not
            %is_summer_month%(round_down(leg.%end_hb%, 24:00)) then
      2 
    else if freedays.%no_of_fs_days_in_month%(leg.%start_hb%) > 3 then
      3
    else if crew.%has_agmt_group_snk_cc_at_date%(leg.%start_hb%) and 
            %next_wop_is_va_and_7_days_or_longer%(leg.%start_hb%) then
      2
    else
      0;

export rule ind_fs_weekend_can_be_granted =
    valid %ind_fs_weekend_can_be_granted_valid% and 
    rule_exceptions.%rule_on%(leg.%start_hb%);

    %ind_fs_weekend_can_be_granted_reason_code% - rule_exceptions.%overshoot_int%(freedays.%free_fs_weekend_month_start_skn_nkf%(leg.%start_hb%)) = 0;

    startdate  = freedays.%free_fs_weekend_month_start_skn_nkf%(leg.%start_hb%);
    enddate  = freedays.%free_fs_weekend_month_end_skn_nkf%(leg.%end_hb%);
    failobject = leg.%failobject_departure%;
    severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
    failtext(Int lhs, Int rhs) = %ind_fs_weekend_can_be_granted_skn_nkf_failtext%(lhs);
    remark  "Coll: Max FS weekend per month",
    planner "Check there is only one FS weekend in calender month";
end

table ind_fs_weekend_can_be_granted_SKN_NKF_failtext_table(int reason_code) =
    reason_code
        ->  %ind_fs_weekend_can_be_granted_skn_nkf_failtext%;
    1   ->  "FS weekend cannot be granted, max one FS weekend per month ";
    2   ->  "FS weekend cannot be granted since there is already a free weekend in month ";
    3   ->  "FS weekend cannot be granted since more than 3 FS days in month ";
    -   ->  "ERROR: Unknown reason code: ";
end



/* Rule:
**   FW (biddable free weekend) grant correctly (SKCMS-649)
**
** Description:
**   This rule checks that FW are bid on a correct and possible date,
**   Conditions for granting FW bit are:
**      An FW must not overlap other activities.
**      FW is Always assigned in pair, Saturday and Sunday.
**      Max 1 granted request, Saturday+ Sunday, per calendar month, Sunday decides to which month a request belongs.
**      FW must not be assigned in a period of 6 Days before planned activities (VAC, LOA, ILL) that are longer than 6 Days.
**      FW must not be assigned during 3 Days after planned activities (VAC, LOA, ILL) that are longer than 6 Days.
**      Minimum distance between FS and FW is 3 Days. Same rule as is valid between 2 FS
*/

/* The FW is put on the roster temporarily before this rule is evaluated.
   If the rule passes, then the roster is committed. */

export rule ind_fw_can_be_granted_SK_FD =
    valid %ind_fw_can_be_granted_SK_FD_valid% ;

    %ind_fw_can_be_granted_SK_FD_reason_code% - rule_exceptions.%overshoot_int%(freedays.%free_weekend_month_start_sk%(trip.%end_hb%) ) = 0;

    startdate  = freedays.%free_weekend_month_start_sk%(trip.%end_hb%);
    enddate  = freedays.%free_weekend_month_end_sk%(trip.%end_hb%);
    failobject = trip.%failobject_start%;
    severity = first(leg(trip), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
    failtext(Int lhs, Int rhs) = %ind_fw_can_be_granted_SK_FD_failtext%(lhs);
    remark  "Coll: Max FW per month",
    planner "Check there is only one FW weekend in calender month";
end


%ind_fw_can_be_granted_SK_FD_valid% =
    roster.%check_rules% and
    %flight_crew% and
    trip.%is_FW% and
/*     not crew.%is_leased_trip_start% and  */
    not crew.%is_SKI% and
    crew.%in_variable_group_trip_start%;



%ind_fw_can_be_granted_SK_FD_reason_code% =
    /* assert that bid starts on Saturday, or on a Sunday if the date is the first of the month (normal two-day FW activity has been split
    into two one-day activities because of roster release) */
    if not (fundamental.%day_of_week%(trip.%start_hb%) = 6) and 
    not (fundamental.%day_of_week%(trip.%start_hb%) = 7 and ((round_down(trip.%start_hb%, 24:00) - round_down_month(trip.%start_hb%)) = 0:00) ) then
        1
    /* assert that FW starts on Saturday morning and is continuing over the whole weekend, unless it's end of month in which
    case it's ok with two separate FW on Saturday and Sunday respectively */
    /* SKAM-664: This was earlier stated like this: 'else if not (trip.%end_hb% - trip.%start_hb% = 48:00) then',
    however this caused problem with daylight savings, hence the more complex expression below*/
    else if not ((time_of_week(trip.%start_hb%) = 120:00 and round_up_week(trip.%start_hb%) = trip.%end_hb%) or
     (time_of_week(trip.%start_hb%) = 120:00 and (round_up(trip.%end_hb%, 24:00) - round_up_month(trip.%start_hb%)) = 0:00)) and    
    not ((time_of_week(trip.%start_hb%) = 144:00 and round_up_week(trip.%start_hb%) = trip.%end_hb%) and 
    ((round_up(trip.%start_hb%, 24:00) - round_up_month(trip.%start_hb%)) = 0:00) ) then
        2
    /* assert no activity overlap during CI/CO of free weekend (FW should be a free weekend at the time of bidding) */
     else if %has_days_in_period_with_activity%(trip.%start_hb%, trip.%end_hb%, "" ) and
                %is_fw_free_weekend_with_CI_CO% then
        3
    /* assert max one FW in month */
    else if %count_days_in_period_with_activity%(
                freedays.%free_weekend_month_start_sk%(trip.%end_hb% ),
                freedays.%free_weekend_month_end_sk%(trip.%end_hb% ),
                "FW") > 2 then
        4
    /* assert not F4 on current month */
    else if freedays.%is_activity_on_month%(trip.%end_hb%, "F4") then
        5
    /* assert not F14 on current month
    else if freedays.%num_free_weekend_with_activity_monthly_sk%(trip.%end_hb%, "F14", false) > 0 then
        6*/
    /* assert FW 6 days before disqualifying activities at length of minimum 7 days SKCMS-1915*/
    else if not %next_activity_placed_correct_fw%(trip.%end_hb%) then
        7
     /* assert FW 3 days before, after FS but FS/FW/FW or FW/FW/FS is acceptable */
    else if %assert_illegal_fw_fs_combination_forwards_backwards%(trip.%start_hb%, trip.%end_hb%) then
        8
    /* assert FW min 3 days after disqualifying activities at length of minimum 7 days SKCMS-1915 */
    else if not %prev_activity_placed_correct_fw%(trip.%start_hb%) then
        9
    else if freedays.%num_free_weekend_with_activities_monthly_sk%(trip.%end_hb%) > 1 or
            freedays.%num_free_weekend_with_activity_monthly_sk%(trip.%end_hb%, "VAC", true) > 0 then
        10
    else if freedays.%num_free_weekend_with_activity_monthly_sk%(trip.%end_hb%, "LOA", true) > 0 then
        11
    else 0;

/* assert FW min 3 days after, before FS but FS/FW/FW or FW/FW/FS is acceptable
*                               FS/FW/FW/3days_no_FS          => acceptable
*                               3days_no_FS/FW/FW/FS          => acceptable
*                               3days_no_FS/FW/FW/3days_no_FS => acceptable
*                               Other cases                   => not acceptable
*/
%assert_illegal_fw_fs_combination_forwards_backwards%(abstime start_hb, abstime end_hb) =
    if %has_days_in_period_with_activity%(start_hb - 24:00, start_hb, "FS") then
        %has_days_in_period_with_activity%(end_hb, end_hb + 72:00, "FS")
    else if %has_days_in_period_with_activity%(end_hb, end_hb + 24:00, "FS") then
        %has_days_in_period_with_activity%(start_hb - 72:00, start_hb, "FS")
    else
        %count_days_in_period_with_activity%(start_hb - 72:00, end_hb + 72:00, "FS") > 0;


%has_days_in_period_with_activity%(Abstime a1, Abstime a2, String codes) =
    %count_days_in_period_with_activity%(a1, a2, codes) > 0;

/*  Checks whether next duty if disqualifying activity after FW is placed correctly. This activity also has to be
*   at least 7 days (%valid_length_activity%) long for the logic to apply.
*/
%next_activity_placed_correct_fw%(Abstime duty_end_day)=
      default(next(duty(chain), %days_since%(duty.%start_day%,duty_end_day) >= %_days_before_fw%)
            where (%check_next_activity_length%(%valid_length_activity%))
            while (%days_since%(duty.%start_day%, duty_end_day) < 10),
          true);

/*  Checks whether prev duty if disqualifying activity before FW is placed correctly. This activity also has to be
*   at least 7 days (%valid_length_activity%) long for the logic to apply.
*/
%prev_activity_placed_correct_fw%(Abstime duty_start_day) =
      default(prev(duty(chain), %days_since%(duty_start_day,duty.%end_day% + 24:00) >= %_days_after_fw%)
            where (%check_prev_activity_length%(%valid_length_activity%))
            while (%days_since%(duty_start_day,duty.%end_day% + 24:00) <  10),
          true);

/*  and all(leg(duty), %count_day_filter%(task.%fs_disqual_activities%)) */

%valid_length_activity% = 6;
%_days_before_fw% = 6;
%_days_after_fw% = 3;

%count_days_in_period_with_activity%(Abstime a1, Abstime a2, String codes) =
    /* String codes is e.g.: "XX"  "XX YY"  etc.
        if codes = "" then all activities counted except FW. */
  sum(trip(roster), trip.%days_in_period%(a1, a2))
  where (all(leg(trip), %count_day_filter%(codes)) and
         trip.%days_in_period%(a1, a2) > 0);


%count_day_filter%(String codes) =
    if codes = "" then
        leg.%code% <> "FW"
    else if length(codes) > 4 then
        locate(leg.%group_code%, codes) > 0 or locate(leg.%code%, codes) > 0
    else
        leg.%code% = codes;


table ind_fw_can_be_granted_SK_FD_failtext_table(int reason_code) =
    reason_code
        ->  %ind_fw_can_be_granted_SK_FD_failtext%;
    1   ->  "FW cannot be granted due to requested FW date must start with Saturday";
    2   ->  "FW cannot be granted due to requested FW date must be a Saturday and Sunday weekend";
    3   ->  "FW cannot be granted due to requested FW date overlap another activity";
    4   ->  "FW cannot be granted due to another FW date is already in the calender month";
    5   ->  "FW cannot be granted due to another free weekend activity (F4) is already in the calender month";
    /* 6   ->  "FW cannot be granted due to another free weekend activity (F14) is already in the calender month"; */
    7   ->  "FW cannot be granted due to requested FW date must place min 6 days before VAC, LOA, or ILL";
    8   ->  "FW cannot be granted due to requested FW date must place min 3 days after or before FS";
    9   ->  "FW cannot be granted due to requested FW date must place min 3 days after VAC, LOA, or ILL";
    10  ->  "FW cannot be granted due to another free weekend activity is already in the calender month";
    11  ->  "FW cannot be granted due to an existing free Saturday, Sunday. Please contact Crew Planning Support if you want to make sure it will be handled as weekendfree";
    -   ->  concat("ERROR: Unknown reason code: ", base_utils.%int2str%(reason_code));
end


%is_fw_free_weekend_with_CI_CO% =
    let start_time = round_down_week(trip.%start_hb%) + freedays.%free_we_start_tow%(1),
        end_time = trip.%end_hb% + freedays.%free_we_end_tow%(1) ;
    default(prev(leg(roster), leg.%end_hb% <= start_time), true) and /* CI time limit */
    default(next(leg(roster), leg.%start_hb% >= end_time), true);   /* CO time limit */

/* create seperation to other parameters following this list in "ALL PARAMETERS" */
%tab_footer% =
  parameter "..."
  remark "#HEADER#...";

/****************************************************************
 * Section 5: Restrictions
 ***************************************************************/
 
/*
** Rule:
**    Prohibit agreement groups from flying AC subtypes
**
** Description:
** Checks which aircraft subtype a specific Agreement Group is 
** prohibited from ** operating.
**
** The prohibited subtypes is defined in agmt_group_set.ac_types_restr
** and each restricted ac types shall be inserted followed by a ";".
** No spaces are allowed
**
** Agreement:
**    SKCMS-849
*/

rule ind_forbidden_ac_subtype =
   valid roster.%check_rules%
   and leg.%in_pp_extended%
   and leg.%is_on_duty%
   and leg.%is_flight_duty%
   and leg.%is_active_flight%;


   crew.%agmt_group_no_of_ac_type_restr_at_date%(leg.%start_utc%,leg.%ac_type%)
   <= 0 + rule_exceptions.%overshoot_int%(leg.%start_UTC%);

   startdate = leg.%start_utc%;
   severity = %severity_filter_int%(leg.%start_utc%,%duty_lh_region%);
   failobject = leg.%failobject_departure%;
   failtext  concat("Coll: Crew not allowed to operate AC subtype ",leg.%ac_type%);
  remark "Coll: Crew not allowed to operate AC subtyte",
  planner "Rule prohibits crew from operating certain aircraft subtype, eg."
          " 33R. This might for example be due to onboard rest facilities not"
          " being approved by the unions";
end

/****
 Monthly parttime
 ***/

rule ind_min_freeday_per_month_monthly_parttime =
        valid roster.%check_rules% and
        model_crew.%is_crew_monthly_parttime_at_date%(crew.%id%, trip.%start_month_start%) and
        trip.%is_last_on_duty_in_month%;
    freedays.%nr_qualifying_in_1_given_month%(trip.%start_month_start%, trip.%start_month_end%) >= 
                    freedays.%min_nr_freedays_parttime%(trip.%start_utc%) -
				         rule_exceptions.%overshoot_int%(trip.%start_UTC%);

   startdate = trip.%start_utc%;
   severity = 0;
   failobject = trip.%failobject_start%;
  failtext(Int value, Int limit) =
    rules.%failtext_int%("Coll: Number of freedays per month, monthly parttime: ", value, limit);
  remark "(CCR) Coll: Min number of freedays in month",
  planner "This rule checks that the number of scheduled freedays"
          " exceeds the minimum amount of freedays, according to"
          " crew contracts entitlements, for a monthly parttime crew";
end



/* ************************************************************************* */

/* Rule:
**   Max F0 in 5 days sequence
**
** Description:
**   This rule checks that no more than 5 F0 days are placed in a sequence.
**
*/
export rule ind_max_f0_in_sequence =
  valid roster.%check_rules% and
      not crew.%is_leased_duty_start% and
        duty.%is_F0% and
        crew.%has_agmt_group_skn_cc% and
        rule_exceptions.%rule_on%(duty.%start_utc%);
  %f0_in_sequence% <= %max_f0_in_sequence%;
  startdate  = duty.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = duty.%failobject_start%;
  failtext(Int value, Int limit) = rules.%failtext_int%("F0 days in 6 days", value, limit);
  remark "Coll: Max F0 days in a sequence",
  planner "Check that no more than 5 F0 day(s)"
          " is scheduled in a sequence";
end


/* only checking backwards since we have whole day activities */
%f0_in_sequence% =
  let days_end = duty.%end_day% + 24:00,
      days_start = days_end - (%max_f0_in_sequence% + 1)*24:00;
  sum(duty(chain), duty.%days_in_period%(days_start, days_end)) from (current) backwards
  while (duty.%end_hb% > days_start)
  where (duty.%is_F0%);

%max_f0_in_sequence% = 5;

/* ************************************************************************* */

/* Rule:
**   Max F3S in 5 days sequence
**
** Description:
**   This rule checks that no more than 5 F3S days are placed in a sequence.
**
*/
export rule ind_max_f3s_in_sequence =
  valid %ind_max_f3s_in_sequence_valid%
        and rule_exceptions.%rule_on%(duty.%start_utc%);

  %f3s_in_sequence% <= %max_f3s_in_sequence%;

  startdate  = duty.%start_UTC%;
  severity = first(leg(duty), %severity_filter_int%(leg.%start_hb%,%duty_lh_region%));
  failobject = duty.%failobject_start%;
  failtext(Int value, Int limit) = rules.%failtext_int%("Too many F3S days in a row", value, limit);
  remark "Coll: Max F3S days in a sequence",
  planner "Check that no more than 5 F3S day(s)"
          " is scheduled in a sequence";
end

export %ind_max_f3s_in_sequence_valid% =
    roster.%check_rules% and
    not crew.%is_leased_duty_start% and
    duty.%is_F3S% and
    %flight_crew%;

/* only checking backwards since we have whole day activities */
%f3s_in_sequence% =
  let days_end = duty.%end_day% + 24:00,
      days_start = days_end - (%max_f3s_in_sequence% + 1)*24:00;
  sum(duty(chain), duty.%days_in_period%(days_start, days_end)) from (current) backwards
  while (duty.%end_hb% > days_start)
  where (duty.%is_F3S%);

%max_f3s_in_sequence% = 5;

/* ************************************************************************* */

/* Rule:
**   This rule checks that crew does not have SingleFUnbid and FS1 activities at the same time
**   Rule is only valid for SNK/NFK VG cabin crew.
**
** Description:
**   If crew has bid to avoid single freedays, FS1 bidding is not allowed.
**
** Agreement: SKCMS-1998
**
*/
export rule ind_no_fs1_with_single_f_unbid =
   valid roster.%check_rules%
   and duty.%in_pp%
   and duty.%is_FS1%
   and crew.%in_variable_group_at_date%(duty.%start_hb%)
   and (crew.%has_agmt_group_skn_cc_at_date%(duty.%start_hb%) or crew.%has_agmt_group_nkf_cc_at_date%(duty.%start_hb%));

   not crew.%spec_sched_unbid_single_f%(duty.%start_hb%);

  startdate = duty.%start_UTC%;
  severity = 0;
  failobject = duty.%failobject_start%;
  failtext "No FS1 with single freeday unbid";
  remark "(CCR): No FS1 with single freeday unbid",
  planner "This rule checks that crew has no single freeday unbid and FS1 at the same time.";
end

/* dummy values redefined by rules_indust_ccr_fc, needed for shared SGT code */
export %co_time_not_zero% = 1jan86;
export %ci_time_at_co_day_plus_offset% = 31dec2099;
/* dummy values redefined by rules_indust_ccr_cc, needed for shared SGT code */
export %sum_of_additional_weekend_days_in_period%(abstime d) = 99;
export %ind_max_duty_time_in_calendar_month_pt_cc_parttime_SKS_monthly_parttime_SKD_valid% = false;

/* end of file */
